mod cdf {
use super as all;
use super::math_builtins;
use super::interval;

type DeviceBuffer = all::DeviceBuffer;
type Vec2 = all::Vec2;

struct DiscreteSample1d {
    off: i32,
    pdf: f32
}

struct ContinuousSample1d {
    off: i32,
    rem: f32,
    pos: f32,
    pdf: f32
}

struct DiscretePdf1d {
    pdf: f32
}

struct ContinuousPdf1d {
    off: i32,
    pdf: f32
}

struct CDF1D {
    func_size:        i32, // This is the function data size, therefore e.g., if function data has size = s, cdf has size = s + 1
    get:              fn (i32) -> f32,
    sample_discrete:  fn (f32) -> DiscreteSample1d,
    pdf_discrete:     fn (i32) -> DiscretePdf1d,
    sample_continuous: fn (f32) -> ContinuousSample1d,
    pdf_continuous:    fn (f32) -> ContinuousPdf1d,
}

// Creates a cdf with func_size + 1 entries accessed by the get function
fn @make_cdf_1d(func_size: i32, get: fn (i32) -> f32) -> CDF1D {
    let pdf_discrete     = @|x:i32| DiscretePdf1d { pdf = get(x + 1) - get(x) };
    let sample_discrete  = @|u:f32| {
        let off = all::min(interval::binary_search(func_size + 1, @|i:i32| get(i) <= u), func_size - 1); // We omit the rare event of u=1 and pull down to u=0.99...
        DiscreteSample1d { off = off, pdf = pdf_discrete(off).pdf }
    };
    let pdf_continuous    = @|x:f32| {
        let off = all::clamp((x * func_size as f32) as i32, 0, func_size - 1);
        ContinuousPdf1d { off = off, pdf = pdf_discrete(off).pdf * func_size as f32}
    };
    let sample_continuous = @|u:f32| {
        let sample = sample_discrete(u);
        let rem    = all::safe_div(u - get(sample.off), sample.pdf);
        let pos    = all::clampf((sample.off as f32 + rem) / func_size as f32, 0, 1);
        ContinuousSample1d { off = sample.off, rem = rem, pos = pos, pdf = sample.pdf * func_size as f32 }
    };

    CDF1D {
        func_size        = func_size,
        get              = get,
        sample_discrete  = sample_discrete,
        pdf_discrete     = pdf_discrete,
        sample_continuous = sample_continuous,
        pdf_continuous    = pdf_continuous
    }
}

// This underlying buffer of the CDF omits the first 0 entry and only contains [x1, x2, ..., xn-1, 1] as data.
// The CDF itself handles [0, x1, x2, ..., xn-1, 1] virtually.
fn @make_cdf_1d_from_buffer(data: DeviceBuffer, func_size: i32, off: i32) 
    = make_cdf_1d(func_size, @|i:i32| if i == 0 { 0 } else { data.load_f32(i - 1 + off) });

////////////////// 2D
struct DiscreteSample2d {
    off: (i32, i32),
    pdf: f32
}

struct ContinuousSample2d {
    off: (i32, i32),
    rem: Vec2,
    pos: Vec2,
    pdf: f32
}

struct DiscretePdf2d {
    pdf: f32
}

struct ContinuousPdf2d {
    off: (i32, i32),
    pdf: f32
}

struct CDF2D {
    sample_discrete:  fn (Vec2) -> DiscreteSample2d,
    pdf_discrete:     fn (i32, i32) -> DiscretePdf2d,
    sample_continuous: fn (Vec2) -> ContinuousSample2d,
    pdf_continuous:    fn (Vec2) -> ContinuousPdf2d,
}

// (x ~ conditional, y ~ marginal)
fn @make_cdf_2d(marginal: CDF1D, conditional: fn (i32) -> CDF1D) -> CDF2D {
    let sample_discrete  = @|uv: Vec2| -> DiscreteSample2d {
        let sample1 = marginal.sample_discrete(uv.y);
        let sample2 = conditional(sample1.off).sample_discrete(uv.x);
    
        DiscreteSample2d {
            off = (sample2.off, sample1.off),
            pdf = sample1.pdf * sample2.pdf
        }
    };
    let pdf_discrete     = @|x: i32, y: i32| -> DiscretePdf2d {
        let pdf1 = marginal.pdf_discrete(y);
        let pdf2 = conditional(y).pdf_discrete(x);
    
        DiscretePdf2d {
            pdf = pdf1.pdf * pdf2.pdf
        }
    };
    let sample_continuous = @|uv: Vec2| -> ContinuousSample2d {
        let sample1 = marginal.sample_continuous(uv.y);
        let sample2 = conditional(sample1.off).sample_continuous(uv.x);
    
        ContinuousSample2d {
            off = (sample2.off, sample1.off),
            rem = all::make_vec2(sample2.rem, sample1.rem),
            pos = all::make_vec2(sample2.pos, sample1.pos),
            pdf = sample1.pdf * sample2.pdf
        }
    };
    let pdf_continuous    = @|pos: Vec2| -> ContinuousPdf2d {
        let pdf1 = marginal.pdf_continuous(pos.y);
        let pdf2 = conditional(pdf1.off).pdf_continuous(pos.x);
    
        ContinuousPdf2d {
            off = (pdf2.off, pdf1.off),
            pdf = pdf1.pdf * pdf2.pdf
        }
    };

    CDF2D {
        sample_discrete  = sample_discrete,
        pdf_discrete     = pdf_discrete,
        sample_continuous = sample_continuous,
        pdf_continuous    = pdf_continuous
    }
}

// First entry is the marginal!
fn @make_cdf_2d_from_buffer(data: DeviceBuffer, size_x: i32, size_y: i32) = make_cdf_2d(
    make_cdf_1d_from_buffer(data, size_y, 0),
    @|i:i32| make_cdf_1d_from_buffer(data, size_x, size_y + i * size_x)
);

fn @make_cdf_2d_sat(entries: CDF1D, slice: i32) -> CDF2D {
    let slice_w   = slice;
    let slice_h   = entries.func_size / slice;
    let slice_w_f = 1 / (slice_w as f32 - 1);
    let slice_h_f = 1 / (slice_h as f32 - 1);

    let sample_discrete = @|uv: Vec2| -> DiscreteSample2d {
        let sample = entries.sample_discrete(uv.x);
    
        let ix = sample.off % slice_w;
        let iy = sample.off / slice_w;
        DiscreteSample2d {
            off = (ix, iy),
            pdf = sample.pdf
        }
    };
    let pdf_discrete = @|x: i32, y: i32| DiscretePdf2d {
        pdf = entries.pdf_discrete(y * slice_w + x).pdf
    };
    let sample_continuous = @|uv: Vec2| -> ContinuousSample2d {
        let sample = entries.sample_discrete(uv.x);
        let rem    = all::safe_div(uv.x - entries.get(sample.off), sample.pdf); // Get unused portion of the floating point
    
        let ix = sample.off % slice_w;
        let iy = sample.off / slice_w;
        ContinuousSample2d {
            off = (ix, iy),
            rem = all::make_vec2(rem, uv.y),
            pos = all::make_vec2((ix as f32 + rem) * slice_w_f, (iy as f32 + uv.y) * slice_h_f),
            pdf = sample.pdf
        }
    };
    let pdf_continuous = @|pos: Vec2| -> ContinuousPdf2d {
        let ix  = all::clamp((pos.x * slice_w as f32) as i32, 0, slice_w - 1);
        let iy  = all::clamp((pos.y * slice_h as f32) as i32, 0, slice_h - 1);
        let pdf = entries.pdf_discrete(iy * slice_w + ix);
    
        ContinuousPdf2d {
            off = (ix, iy),
            pdf = pdf.pdf
        }
    };

    CDF2D {
        sample_discrete  = sample_discrete,
        pdf_discrete     = pdf_discrete,
        sample_continuous = sample_continuous,
        pdf_continuous    = pdf_continuous
    }
}

fn @make_cdf_2d_sat_from_buffer(data: DeviceBuffer, size: i32, slice: i32) = make_cdf_2d_sat(
    make_cdf_1d_from_buffer(data, size, 0), slice
);

fn @make_cdf_2d_hierachical(data: DeviceBuffer, slice: i32, levels: i32) -> CDF2D {
    // Assumptions: The mip-map levels are in sequential order, with level 0 being the initial image. The image is also square!
    let i_slice_f = 1 / (slice as f32 - 1);

    fn @get_offset(l: i32) = math_builtins::ceil((slice * slice) as f32 * (4 - 1.0 / (1 << (2 * l)) as f32) / 3) as i32 - slice * slice;

    fn @lookup(x: i32, y: i32, l: i32) {
        let s = slice / (1 << l);
        data.load_f32(get_offset(l) + y * s + x)
    }
    
    fn @sample_discrete(mut uv: Vec2) -> DiscreteSample2d {
        let mut ix = 0:i32;
        let mut iy = 0:i32; 
        let mut pdf = 0:f32;
        for li in all::safe_unroll(0, levels) {
            let l = levels - li - 1; // We go backwards
            
            let x00 = lookup(ix + 0, iy + 0, l);
            let x01 = lookup(ix + 1, iy + 0, l);
            let x10 = lookup(ix + 0, iy + 1, l);
            let x11 = lookup(ix + 1, iy + 1, l);

            let u = (x00 + x10) / (x00 + x01 + x10 + x11);
            if u < uv.x {
                // Select left
                ix += 0;
                uv.x *= 2;
                pdf *= u;
            } else {
                // Select right
                ix += slice / (1 << (l+1)); // Step half of the slice
                uv.x = 2 * uv.x - 1;
                pdf *= 1 - u;
            }

            let v = if u < uv.x { x00 / (x00 + x10) } else { x01 / (x01 + x11) };
            if v < uv.y {
                // Select top
                iy += 0;
                uv.y *= 2;
                pdf *= v;
            } else {
                // Select bottom
                iy += slice / (1 << (l+1)); // Step half of the slice
                uv.y = 2 * uv.y - 1;
                pdf *= 1 - v;
            }
        }

        DiscreteSample2d {
            off = (ix, iy),
            pdf = pdf
        }
    }

    fn @pdf_discrete(mut x: i32, mut y: i32) -> DiscretePdf2d {
        let mut ix = 0:i32;
        let mut iy = 0:i32; 
        let mut pdf = 0:f32;
        for li in all::safe_unroll(0, levels) {
            let l = levels - li - 1; // We go backwards
            let k = slice / (1 << l);
            
            let x00 = lookup(ix + 0, iy + 0, l);
            let x01 = lookup(ix + 1, iy + 0, l);
            let x10 = lookup(ix + 0, iy + 1, l);
            let x11 = lookup(ix + 1, iy + 1, l);

            let u = (x00 + x10) / (x00 + x01 + x10 + x11);
            let v = if x < k { x00 / (x00 + x10) } else { x01 / (x01 + x11) };

            if x < k {
                // Select left
                ix += 0;
                x += 0;
                pdf *= u;
            } else {
                // Select right
                ix += slice / (1 << (l + 1));
                x -= k/2;
                pdf *= 1 - u;
            }

            if y < k {
                // Select top
                iy += 0;
                y += 0;
                pdf *= v;
            } else {
                // Select bottom
                iy += slice / (1 << (l + 1));
                y -= k/2;
                pdf *= 1 - v;
            }
        }

        DiscretePdf2d { pdf = pdf }
    }

    fn @sample_continuous(uv: Vec2) -> ContinuousSample2d {
        let sample = sample_discrete(uv); // TODO
        ContinuousSample2d {
            off = sample.off,
            rem = all::make_vec2(0, 0),
            pos = all::make_vec2((sample.off.0 as f32) * i_slice_f, (sample.off.1 as f32) * i_slice_f),
            pdf = sample.pdf
        }
    };
    let pdf_continuous = @|pos: Vec2| -> ContinuousPdf2d {
        let ix  = all::clamp((pos.x * i_slice_f) as i32, 0, slice - 1);
        let iy  = all::clamp((pos.y * i_slice_f) as i32, 0, slice - 1);
        let pdf = pdf_discrete(ix, iy).pdf; // TODO
    
        ContinuousPdf2d {
            off = (ix, iy),
            pdf = pdf
        }
    };

    CDF2D {
        sample_discrete  = sample_discrete,
        pdf_discrete     = pdf_discrete,
        sample_continuous = sample_continuous,
        pdf_continuous    = pdf_continuous
    }
}

}