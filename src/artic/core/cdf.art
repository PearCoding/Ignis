mod cdf {
use super as all;
use super::math_builtins;
use super::interval;
use super::math;

type DeviceBuffer = all::DeviceBuffer;
type Vec2 = all::Vec2;

struct DiscreteSample1d {
    off: i32,
    pdf: f32
}

struct ContinuousSample1d {
    off: i32,
    rem: f32,
    pos: f32,
    pdf: f32
}

struct DiscretePdf1d {
    pdf: f32
}

struct ContinuousPdf1d {
    off: i32,
    pdf: f32
}

struct CDF1D {
    func_size:        i32, // This is the function data size, therefore e.g., if function data has size = s, cdf has size = s + 1
    get:              fn (i32) -> f32,
    sample_discrete:  fn (f32) -> DiscreteSample1d,
    pdf_discrete:     fn (i32) -> DiscretePdf1d,
    sample_continuous: fn (f32) -> ContinuousSample1d,
    pdf_continuous:    fn (f32) -> ContinuousPdf1d,
}

// Creates a cdf with func_size + 1 entries accessed by the get function
fn @make_cdf_1d(func_size: i32, get: fn (i32) -> f32) -> CDF1D {
    let pdf_discrete     = @|x:i32| DiscretePdf1d { pdf = get(x + 1) - get(x) };
    let sample_discrete  = @|u:f32| {
        let off = all::min(interval::binary_search(func_size + 1, @|i:i32| get(i) <= u), func_size - 1); // We omit the rare event of u=1 and pull down to u=0.99...
        DiscreteSample1d { off = off, pdf = pdf_discrete(off).pdf }
    };
    let pdf_continuous    = @|x:f32| {
        let off = all::clamp((x * func_size as f32) as i32, 0, func_size - 1);
        ContinuousPdf1d { off = off, pdf = pdf_discrete(off).pdf * func_size as f32}
    };
    let sample_continuous = @|u:f32| {
        let sample = sample_discrete(u);
        let rem    = all::safe_div(u - get(sample.off), sample.pdf);
        let pos    = all::clampf((sample.off as f32 + rem) / func_size as f32, 0, 1);
        ContinuousSample1d { off = sample.off, rem = rem, pos = pos, pdf = sample.pdf * func_size as f32 }
    };

    CDF1D {
        func_size        = func_size,
        get              = get,
        sample_discrete  = sample_discrete,
        pdf_discrete     = pdf_discrete,
        sample_continuous = sample_continuous,
        pdf_continuous    = pdf_continuous
    }
}

// This underlying buffer of the CDF omits the first 0 entry and only contains [x1, x2, ..., xn-1, 1] as data.
// The CDF itself handles [0, x1, x2, ..., xn-1, 1] virtually.
fn @make_cdf_1d_from_buffer(data: DeviceBuffer, func_size: i32, off: i32) 
    = make_cdf_1d(func_size, @|i:i32| if i == 0 { 0 } else { data.load_f32(i - 1 + off) });

////////////////// 2D
struct DiscreteSample2d {
    off: (i32, i32),
    pdf: f32
}

struct ContinuousSample2d {
    off: (i32, i32),
    rem: Vec2,
    pos: Vec2,
    pdf: f32
}

struct DiscretePdf2d {
    pdf: f32
}

struct ContinuousPdf2d {
    off: (i32, i32),
    pdf: f32
}

struct CDF2D {
    sample_discrete:  fn (Vec2) -> DiscreteSample2d,
    pdf_discrete:     fn (i32, i32) -> DiscretePdf2d,
    sample_continuous: fn (Vec2) -> ContinuousSample2d,
    pdf_continuous:    fn (Vec2) -> ContinuousPdf2d,
}

// (x ~ conditional, y ~ marginal)
fn @make_cdf_2d(marginal: CDF1D, conditional: fn (i32) -> CDF1D) -> CDF2D {
    let sample_discrete  = @|uv: Vec2| -> DiscreteSample2d {
        let sample1 = marginal.sample_discrete(uv.y);
        let sample2 = conditional(sample1.off).sample_discrete(uv.x);
    
        DiscreteSample2d {
            off = (sample2.off, sample1.off),
            pdf = sample1.pdf * sample2.pdf
        }
    };
    let pdf_discrete     = @|x: i32, y: i32| -> DiscretePdf2d {
        let pdf1 = marginal.pdf_discrete(y);
        let pdf2 = conditional(y).pdf_discrete(x);
    
        DiscretePdf2d {
            pdf = pdf1.pdf * pdf2.pdf
        }
    };
    let sample_continuous = @|uv: Vec2| -> ContinuousSample2d {
        let sample1 = marginal.sample_continuous(uv.y);
        let sample2 = conditional(sample1.off).sample_continuous(uv.x);
    
        ContinuousSample2d {
            off = (sample2.off, sample1.off),
            rem = all::make_vec2(sample2.rem, sample1.rem),
            pos = all::make_vec2(sample2.pos, sample1.pos),
            pdf = sample1.pdf * sample2.pdf
        }
    };
    let pdf_continuous    = @|pos: Vec2| -> ContinuousPdf2d {
        let pdf1 = marginal.pdf_continuous(pos.y);
        let pdf2 = conditional(pdf1.off).pdf_continuous(pos.x);
    
        ContinuousPdf2d {
            off = (pdf2.off, pdf1.off),
            pdf = pdf1.pdf * pdf2.pdf
        }
    };

    CDF2D {
        sample_discrete  = sample_discrete,
        pdf_discrete     = pdf_discrete,
        sample_continuous = sample_continuous,
        pdf_continuous    = pdf_continuous
    }
}

// First entry is the marginal!
fn @make_cdf_2d_from_buffer(data: DeviceBuffer, size_x: i32, size_y: i32) = make_cdf_2d(
    make_cdf_1d_from_buffer(data, size_y, 0),
    @|i:i32| make_cdf_1d_from_buffer(data, size_x, size_y + i * size_x)
);

fn @make_cdf_2d_sat(entries: CDF1D, slice: i32) -> CDF2D {
    let slice_w   = slice;
    let slice_h   = entries.func_size / slice;
    let slice_w_f = 1 / (slice_w as f32 - 1);
    let slice_h_f = 1 / (slice_h as f32 - 1);

    let sample_discrete = @|uv: Vec2| -> DiscreteSample2d {
        let sample = entries.sample_discrete(uv.x);
    
        let ix = sample.off % slice_w;
        let iy = sample.off / slice_w;
        DiscreteSample2d {
            off = (ix, iy),
            pdf = sample.pdf
        }
    };
    let pdf_discrete = @|x: i32, y: i32| DiscretePdf2d {
        pdf = entries.pdf_discrete(y * slice_w + x).pdf
    };
    let sample_continuous = @|uv: Vec2| -> ContinuousSample2d {
        let sample = entries.sample_discrete(uv.x);
        let rem    = all::safe_div(uv.x - entries.get(sample.off), sample.pdf); // Get unused portion of the floating point
    
        let ix = sample.off % slice_w;
        let iy = sample.off / slice_w;
        ContinuousSample2d {
            off = (ix, iy),
            rem = all::make_vec2(rem, uv.y),
            pos = all::make_vec2((ix as f32 + rem) * slice_w_f, (iy as f32 + uv.y) * slice_h_f),
            pdf = sample.pdf
        }
    };
    let pdf_continuous = @|pos: Vec2| -> ContinuousPdf2d {
        let ix  = all::clamp((pos.x * slice_w as f32) as i32, 0, slice_w - 1);
        let iy  = all::clamp((pos.y * slice_h as f32) as i32, 0, slice_h - 1);
        let pdf = entries.pdf_discrete(iy * slice_w + ix);
    
        ContinuousPdf2d {
            off = (ix, iy),
            pdf = pdf.pdf
        }
    };

    CDF2D {
        sample_discrete  = sample_discrete,
        pdf_discrete     = pdf_discrete,
        sample_continuous = sample_continuous,
        pdf_continuous    = pdf_continuous
    }
}

fn @make_cdf_2d_sat_from_buffer(data: DeviceBuffer, size: i32, slice: i32) = make_cdf_2d_sat(
    make_cdf_1d_from_buffer(data, size, 0), slice
);

fn @make_cdf_2d_hierachical(data: DeviceBuffer, levels: i32) -> CDF2D {
    // Assumptions: The mip-map levels are in sequential order, with level 0 being the initial image. The image is also square!
    let slice   = 1 << levels;
    let slice_f = slice as f32;

    fn @get_offset(l: i32) = ((1 << (2 * (levels + 1))) - (1 << (2 * (levels - l + 1)))) / 3;

    fn @lookup(x: i32, y: i32, l: i32) {
        let s = slice / (1 << l);
        data.load_f32(get_offset(l) + y * s + x)
    }
    
    fn @sample_discrete2(mut uv: Vec2) -> (DiscreteSample2d, Vec2) {
        let mut ix = 0:i32;
        let mut iy = 0:i32; 
        for li in all::safe_unroll(0, levels) {
            let l = levels - li - 1; // We go backwards
            
            let x00 = lookup(ix + 0, iy + 0, l);
            let x01 = lookup(ix + 1, iy + 0, l);
            let x10 = lookup(ix + 0, iy + 1, l);
            let x11 = lookup(ix + 1, iy + 1, l);

            let u = (x00 + x10) / (x00 + x01 + x10 + x11);
            let v = if uv.x < u {
                // Select left
                ix   = 2 * ix   + 0; 
                uv.x = 2 * uv.x - 0;
                x00 / (x00 + x10)
            } else {
                // Select right
                ix   = 2 * ix   + 1; 
                uv.x = 2 * uv.x - 1;
                x01 / (x01 + x11)
            };

            if uv.y < v {
                // Select top
                iy   = 2 * iy   + 0; 
                uv.y = 2 * uv.y - 0;
            } else {
                // Select bottom
                iy   = 2 * iy   + 1; 
                uv.y = 2 * uv.y - 1;
            }
        }

        (DiscreteSample2d {
            off = (ix, iy),
            pdf = lookup(ix, iy, 0) / (slice * slice) as f32
        },
        uv /*Remainder*/)
    }

    fn @sample_discrete(uv: Vec2)    = sample_discrete2(uv).0;
    fn @pdf_discrete(x: i32, y: i32) = DiscretePdf2d { pdf = lookup(x, y, 0) / (slice * slice) as f32 }; // TODO: Check if division is really necessary

    fn @pdf_continuous(pos: Vec2) -> ContinuousPdf2d {
        let x = pos.x * (slice - 1) as f32;
        let y = pos.y * (slice - 1) as f32;

        let ix = all::clamp(x as i32, 0, slice - 1);
        let iy = all::clamp(y as i32, 0, slice - 1);
    
        ContinuousPdf2d {
            off = (ix, iy),
            pdf = lookup(ix, iy, 0)
        }
    }

    fn @sample_continuous(uv: Vec2) -> ContinuousSample2d {
        let (sample, rem) = sample_discrete2(uv);
        let pos = all::make_vec2((sample.off.0 as f32 + rem.x) / slice_f, (sample.off.1 as f32 + rem.y) / slice_f);
        ContinuousSample2d {
            off = sample.off,
            rem = rem,
            pos = pos,
            pdf = sample.pdf * slice_f * slice_f
        }
    }

    CDF2D {
        sample_discrete   = sample_discrete,
        pdf_discrete      = pdf_discrete,
        sample_continuous = sample_continuous,
        pdf_continuous    = pdf_continuous
    }
}

}