struct Color {
    r: f32,
    g: f32,
    b: f32,
    a: f32
}

fn @make_color(r: f32, g: f32, b: f32, a: f32) = Color { r = r, g = g, b = b, a = a };
fn @make_gray_color(g: f32) = make_color(g, g, g, 1);

fn @color_add(a: Color, b: Color)  = make_color(a.r + b.r, a.g + b.g, a.b + b.b, math_builtins::fmin[f32](1, a.a + b.a));
fn @color_sub(a: Color, b: Color)  = make_color(a.r - b.r, a.g - b.g, a.b - b.b, math_builtins::fmax[f32](0, a.a - b.a));
fn @color_diff(a: Color, b: Color) = make_color(math_builtins::fabs(a.r - b.r), math_builtins::fabs(a.g - b.g), math_builtins::fabs(a.b - b.b), math_builtins::fabs(a.a - b.a));
fn @color_mul(a: Color, b: Color)  = make_color(a.r * b.r, a.g * b.g, a.b * b.b, a.a * b.a);
fn @color_mulf(c: Color, f: f32)   = make_color(c.r * f, c.g * f, c.b * f, c.a * f);
fn @color_divf(c: Color, f: f32)   = make_color(c.r / f, c.g / f, c.b / f, c.a / f);
fn @color_lerp(a: Color, b: Color, t: f32) = make_color(
    (1 - t) * a.r + t * b.r,
    (1 - t) * a.g + t * b.g,
    (1 - t) * a.b + t * b.b,
    (1 - t) * a.a + t * b.a);

fn @color_map(c: Color, f: fn (f32) -> f32) = make_color(@f(c.r), @f(c.g), @f(c.b), @f(c.a));

fn @color_abs(a: Color)              = make_color(math_builtins::fabs(a.r), math_builtins::fabs(a.g), math_builtins::fabs(a.b), math_builtins::fabs(a.a));
fn @color_saturate(a: Color, f: f32) = make_color(math_builtins::fmin[f32](a.r, f), math_builtins::fmin[f32](a.g, f), math_builtins::fmin[f32](a.b, f), math_builtins::fmin[f32](a.a, f));

fn @color_average(c: Color)   = (c.r + c.g + c.b) / 3;
fn @color_luminance(c: Color) = c.r * 0.2126 + c.g * 0.7152 + c.b * 0.0722;

// Will normalize such that one of the r,g,b components is 1. Ignores the alpha channel
fn @color_normalize(c: Color)         = color_replace_a(color_mulf(c, safe_div(1, color_max_component(c))), c.a);
fn @color_replace_a(c: Color, a: f32) = make_color(c.r, c.g, c.b, a);

// The following functions ignore the alpha component
fn @color_max_component(c: Color) = vec3_max_value(color_to_vec3(c));
fn @color_max_index(c: Color)     = vec3_max_index(color_to_vec3(c));
fn @color_min_component(c: Color) = vec3_min_value(color_to_vec3(c));
fn @color_min_index(c: Color)     = vec3_min_index(color_to_vec3(c));

fn @color_max(a: Color, b: Color) = vec4_to_color(vec4_max(color_to_vec4(a), color_to_vec4(b)));
fn @color_min(a: Color, b: Color) = vec4_to_color(vec4_min(color_to_vec4(a), color_to_vec4(b)));

fn @is_black(c: Color) = (c.r == 0 && c.g == 0 && c.b == 0);
fn @is_white(c: Color) = (c.r == 1 && c.g == 1 && c.b == 1);
fn @color_is_equal_eps(a: Color, b: Color, eps: f32) -> bool {
    let diff = color_abs(color_sub(a, b));
    diff.r <= eps && diff.g <= eps && diff.b <= eps
}
fn @is_black_eps(c: Color, eps: f32) = color_is_equal_eps(c, color_builtins::black, eps);
fn @is_white_eps(c: Color, eps: f32) = color_is_equal_eps(c, color_builtins::white, eps);
fn @color_is_finite(c: Color)        = math_builtins::isfinite(c.r) && math_builtins::isfinite(c.g) && math_builtins::isfinite(c.b);

fn @vec3_to_color(v: Vec3)  = make_color(v.x, v.y, v.z, 1);
fn @vec4_to_color(v: Vec4)  = make_color(v.x, v.y, v.z, v.w);
fn @color_to_vec3(c: Color) = make_vec3(c.r, c.g, c.b);
fn @color_to_vec4(c: Color) = make_vec4(c.r, c.g, c.b, c.a);

fn @color_at(a: Color, i: i32) = vec4_at(color_to_vec4(a), i);

mod color_builtins {
static black   = super::Color { r = 0, g = 0, b = 0, a = 1 };
static white   = super::Color { r = 1, g = 1, b = 1, a = 1 };
static pink    = super::Color { r = 1, g = 0, b = 1, a = 1 }; 
static red     = super::Color { r = 1, g = 0, b = 0, a = 1 }; 
static green   = super::Color { r = 0, g = 1, b = 0, a = 1 }; 
static blue    = super::Color { r = 0, g = 0, b = 1, a = 1 }; 
static yellow  = super::Color { r = 1, g = 1, b = 0, a = 1 }; 
static magenta = super::Color { r = 1, g = 0, b = 1, a = 1 };
static cyan    = super::Color { r = 0, g = 1, b = 1, a = 1 };  
static orange  = super::Color { r = 1, g = 0.5, b = 0, a = 1 }; 

// Color used to indicate true & false (we use blue instead of green, like Blender, for people with color vision deficiency)
static true_color  = blue; 
static false_color = red; 

static max_efficiency   = 683:f32; // Defined maximum at 550 nm
static white_efficiency = 179:f32; // Uniform white light (Standard illuminant E)
static d65_efficiency   = 203:f32; // Standard illuminant D65
}

fn @xyz_to_srgb(c : Color) -> Color {
    make_color( 3.2404542 * c.r - 1.5371385 * c.g - 0.4985314 * c.b,
               -0.9692660 * c.r + 1.8760108 * c.g + 0.0415560 * c.b,
                0.0556434 * c.r - 0.2040259 * c.g + 1.0572252 * c.b,
                c.a)
}

fn @srgb_to_xyz(c : Color) -> Color {
    make_color(0.4124564 * c.r + 0.3575761 * c.g + 0.1804375 * c.b,
               0.2126729 * c.r + 0.7151522 * c.g + 0.0721750 * c.b,
               0.0193339 * c.r + 0.1191920 * c.g + 0.9503041 * c.b,
               c.a)
}

fn @xyY_to_srgb(c : Color) -> Color {
    if c.g <= flt_eps { color_builtins::black } else { xyz_to_srgb(make_color(c.r * c.b / c.g, c.b, (1 - c.r - c.g) * c.b / c.g, c.a)) }
}

fn @srgb_to_xyY(c : Color) -> Color {
    let s = srgb_to_xyz(c);
    let n = s.r + s.g + s.b;
    if n <= flt_eps { color_builtins::black } else { make_color(s.r / n, s.g / n, s.g, 1) }
}

mod tonemapping {
    fn @reinhard(L : f32) -> f32 {
        super::safe_div(L, 1.0 + L)
    }

    fn @reinhard_modified(L : f32) -> f32 {
        let WhitePoint = 4 : f32;
        super::safe_div(L * (1.0 + L / (WhitePoint * WhitePoint)), 1.0 + L)
    }

    // Narkowicz 2015, "ACES Filmic Tone Mapping Curve"
    fn @aces(L: f32) -> f32 {
        let A = 2.51 : f32;
        let B = 0.03 : f32;
        let C = 2.43 : f32;
        let D = 0.59 : f32;
        let E = 0.14 : f32;
        super::safe_div(L * (A * L + B), L * (C * L + D) + E)
    }

    // Based on http://filmicworlds.com/blog/filmic-tonemapping-operators/
    fn @uncharted2(L: f32) -> f32 {
        fn @func(x: f32) -> f32 {
            let A = 0.15 : f32;
            let B = 0.50 : f32;
            let C = 0.10 : f32;
            let D = 0.20 : f32;
            let E = 0.02 : f32;
            let F = 0.30 : f32;
            ((x*(A*x + C*B) + D*E)/(x*(A*x + B) + D*F)) - E/F
        }
        func(L) / func(11.2)
    }

    // Based on https://modelviewer.dev/examples/tone-mapping
    fn @pbr_neutral(mut c: super::Color, desaturation: f32, compression: f32) -> super::Color {
        let a = c.a;
        let x = super::color_min_component(c);
        c = super::color_sub(c, super::color_mulf(super::color_builtins::white, super::select(x < 0.08, x - 6.25 * x * x, 0.04:f32)));

        let  p = super::color_max_component(c);
        if p < compression {
            c.{ a = a /* Keep alpha */}
        } else {
            let d  = 1 - compression;
            let np = 1 - d * d / (p + d - compression);
            c = super::color_mulf(c, np / p);

            let t = 1 - 1 / (desaturation * (p - np) + 1);
            super::color_lerp(c, super::color_mulf(super::color_builtins::white, np), t).{ a = a /* Keep alpha */}
        }
    }

    fn @pbr_neutral_std(c: super::Color) = pbr_neutral(c, 0.15, 0.8 - 0.04);

    // Based on https://www.shadertoy.com/view/cd3XWr
    fn @agx(c: super::Color) -> super::Color {
        let a = c.a;
        let mut v = super::color_to_vec3(c);

        let M  = super::make_mat3x3(super::make_vec3(0.842479062253094, 0.0784335999999992, 0.0792237451477643),  super::make_vec3(0.0423282422610123, 0.878468636469772, 0.0791661274605434),  super::make_vec3(0.0423756549057051, 0.0784336, 0.879142973793104));
        let IM = super::make_mat3x3(super::make_vec3(1.19687900512017, -0.0980208811401368, -0.0990297440797205), super::make_vec3(-0.0528968517574562, 1.15190312990417, -0.0989611768448433), super::make_vec3(-0.0529716355144438, -0.0980434501171241, 1.15107367264116));

        let min_ev = -12.47393:f32;
        let max_ev =  4.026069:f32;

        // Input transform
        v = super::mat3x3_mul(M, v);

        // Log2 space encoding
        v = super::vec3_map(v, @|x| (super::clampf(super::math_builtins::log2(x), min_ev, max_ev) - min_ev) / (max_ev - min_ev));

        // Mean error^2: 3.6705141e-06
        fn @defaultContrastApprox(x: f32) -> f32 {
            let x2 = x * x;
            let x4 = x2 * x2;
            
            + 15.5    * x4 * x2
            - 40.14   * x4 * x
            + 31.96   * x4
            - 6.868   * x2 * x
            + 0.4298  * x2
            + 0.1191  * x
            - 0.00232
        }

        // Apply sigmoid function approximation
        v = super::vec3_map(v, defaultContrastApprox);

        // Undo input transform
        v = super::mat3x3_mul(IM, v);

        // sRGB IEC 61966-2-1 2.2 Exponent Reference EOTF Display (aka. linearizing the stuff again)
        v = super::vec3_map(v, @|x| super::math_builtins::pow(x, 2.2:f32));

        super::vec3_to_color(v).{ a = a /* Keep alpha */}
    }
}

fn @srgb_gamma(x : f32) -> f32 {
    if x <= 0.0031308 {
        12.92 * x
    } else {
        1.055 * math_builtins::pow[f32](x, 0.416666667) - 0.055
    }
}

fn @srgb_invgamma(x : f32) -> f32 {
    if x <= 0.04045 {
        x / 12.92
    } else {
        (math_builtins::pow[f32](x, 2.4) + 0.055) / 1.055
    }
}

// Will offset and scale such that the minimum value becomes 0 and maximum value becomes 1
fn @color_full_saturate(c: Color) -> Color {
    let min_v = color_min_component(c);
    let min_c = make_color(c.r - min_v, c.g - min_v, c.b - min_v, c.a);
    let max_v = color_max_component(min_c);
    let norm  = safe_div(1, max_v);
    make_color(min_c.r * norm, min_c.g * norm, min_c.b * norm, min_c.a)
}

// See https://gist.github.com/983/e170a24ae8eba2cd174f
fn @srgb_to_hsv(c: Color) -> Color {
    let step = @|edge:f32, x:f32| select(x < edge, 0:f32, 1:f32);
    
    let p = vec4_lerp(make_vec4(c.b, c.g, -1, 2 / (3 : f32)), make_vec4(c.g, c.b, 0, -1 / (3:f32)), step(c.b, c.g));
    let q = vec4_lerp(make_vec4(p.x, p.y, p.w, c.r), make_vec4(c.r, p.y, p.z, p.x), step(p.x, c.r));

    let d = q.x - math_builtins::fmin(q.w, q.y);
    let e = 1.0e-10:f32;
    make_color(
        math_builtins::fabs(q.z + (q.w - q.y) / (6 * d + e)),
        d / (q.x + e),
        q.x,
        c.a)
}

fn @hsv_to_srgb(c: Color) -> Color {
    fn fract_v(v: Vec3) = vec3_map(v, @|x| x - math_builtins::floor(x));

    let p = vec3_abs(vec3_sub(vec3_mulf(fract_v(make_vec3(c.r + 1, c.r + 2 / (3:f32), c.r + 1 / (3:f32))), 6), vec3_expand(3)));
    make_color(
        c.b * lerp(1, clampf(p.x - 1, 0, 1), c.g),
        c.b * lerp(1, clampf(p.y - 1, 0, 1), c.g),
        c.b * lerp(1, clampf(p.z - 1, 0, 1), c.g),
        c.a)
}

fn @srgb_to_hsl(c: Color) -> Color {
    let hsv = srgb_to_hsv(c);
    let l   = hsv.g * (1 - hsv.b / 2);
    make_color(
        hsv.r,
        l,
        safe_div(hsv.g - l, math_builtins::fmin(l, 1 - l)),
        hsv.a)
}

fn @hsl_to_srgb(c: Color) -> Color {
    let v   = c.b + c.g * math_builtins::fmin(c.b, 1 - c.b);
    let hsv = make_color(
        c.r,
        v,
        2 * safe_div(v - c.b, v),
        c.a);
    hsv_to_srgb(hsv)
}

// Special mix functions used in nodes
fn @color_mix_screen(a: Color, b: Color, t: f32) {
    color_sub(color_builtins::white, color_mul(color_lerp(color_builtins::white, color_sub(color_builtins::white, b), t), color_sub(color_builtins::white, a)))
}

fn @color_mix_overlay(a: Color, b: Color, t: f32) {
    vec3_to_color(vec3_zip(color_to_vec3(a), color_to_vec3(b), @|x,y|{
        select(x < 0.5, x * lerp(1, 2*y, t), 1 - (1 - x)*lerp(1, 2*(1 - y), t))
    }))
}

fn @color_mix_dodge(a: Color, b: Color, t: f32) {
    vec3_to_color(vec3_zip(color_to_vec3(a), color_to_vec3(b), @|x,y|{
        let d = math_builtins::fmin[f32](1, safe_div(x, 1 - t * y));
        select(x == 0, x, select(d < 0, 1:f32, d))
    }))
}

fn @color_mix_burn(a: Color, b: Color, t: f32) {
    vec3_to_color(vec3_zip(color_to_vec3(a), color_to_vec3(b), @|x,y|{
        let d = lerp(1, y, t);
        select(d <= flt_eps, 0:f32, clampf(1 - safe_div(1 - x, d), 0, 1))
    }))
}

fn @color_mix_soft(a: Color, b: Color, t: f32) {
    let scr = color_sub(color_builtins::white, color_mul(color_sub(color_builtins::white, a), color_sub(color_builtins::white, b)));
    color_lerp(a, color_add(color_mul(color_mul(color_sub(color_builtins::white, a), a), b), color_mul(a, scr)), t)
}

fn @color_mix_linear(a: Color, b: Color, t: f32) {
    color_add(a, vec3_to_color(vec3_map(color_to_vec3(b), @|y|{
        select(y > 0.5, 2 * (y-0.5), 2*y-1) * t
    })))
}

fn @color_mix_hue(a: Color, b: Color, t: f32) {
    let ahsv = srgb_to_hsv(a);
    let bhsv = srgb_to_hsv(b);
    color_lerp(a, hsv_to_srgb(make_color(bhsv.r, ahsv.g, ahsv.b, ahsv.a)), t)
}

fn @color_mix_saturation(a: Color, b: Color, t: f32) {
    let ahsv = srgb_to_hsv(a);
    let bhsv = srgb_to_hsv(b);
    hsv_to_srgb(make_color(ahsv.r, lerp(ahsv.g, bhsv.g, t), ahsv.b, ahsv.a))
}

fn @color_mix_value(a: Color, b: Color, t: f32) {
    let ahsv = srgb_to_hsv(a);
    let bhsv = srgb_to_hsv(b);
    hsv_to_srgb(make_color(ahsv.r, ahsv.g, lerp(ahsv.b, bhsv.b, t), ahsv.a))
}

fn @color_mix_color(a: Color, b: Color, t: f32) {
    let ahsv = srgb_to_hsv(a);
    let bhsv = srgb_to_hsv(b);
    color_lerp(a, hsv_to_srgb(make_color(bhsv.r, bhsv.g, ahsv.b, ahsv.a)), t)
}

fn @encode_rgbe(color: Color) -> i32 {
    let max = color_max_component(color);
    if max <= flt_eps {
        0
    } else {
        let (val, exp) = frexp(max);
        let val2 = val * 256 / max;
        let r = (color.r * val2) as i32 & 0xFF;
        let g = (color.g * val2) as i32 & 0xFF;
        let b = (color.b * val2) as i32 & 0xFF;
        (r << 24) | (g << 16) | (b << 8) | (exp + 128)
    }
}

fn @decode_rgbe(color: i32) -> Color {
    if color == 0 {
        color_builtins::black
    } else {
        let r = ((color >> 24) & 0xFF) as f32;
        let g = ((color >> 16) & 0xFF) as f32;
        let b = ((color >>  8) & 0xFF) as f32;
        let e = (color & 0xFF);
        let f = ldexp(1, e - 128 - 8);

        make_color(r * f, g * f, b * f, 1)
    }
}