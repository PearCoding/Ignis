struct GPUKernelConfiguration {
    block_size_traversal_primary:        i32,
    block_size_traversal_secondary:      i32,
    block_size_hit:                      i32,
    block_size_miss:                     i32,
    block_size_advanced_shadow_hit:      i32,
    block_size_advanced_shadow_miss:     i32,
    block_size_generate_rays:            i32,
    block_size_sort_primary:             i32,
    block_size_sort_secondary_simple:    i32,
    block_size_sort_secondary_materials: i32,
    block_size_compact_primary:          i32,
    block_size_reset:                    i32,
    block_size_parallel_range_1d:        i32,
    block_size_parallel_range_2d:        i32,
    block_size_parallel_reduce:          i32,
    stream_capacity:                     i32,
}

fn @gpu_request_buffer(name: &[u8], size: i32, accb: DeviceBufferAccessor) -> DeviceBuffer {
    let mut ptr : &[u8];
    ignis_request_buffer(name, &mut ptr, size * sizeof[i32]() as i32, 0);
    accb(ptr as &[f32], size)
}

fn @gpu_get_film_data() -> (&mut [f32], i32, i32) {
    let mut film_pixels : &mut [f32];
    let mut film_width  : i32;
    let mut film_height : i32;
    ignis_get_film_data(&mut film_pixels, &mut film_width, &mut film_height);
    (film_pixels, film_width, film_height)
}

fn @gpu_get_aov_image(id: &[u8], w: i32, h: i32, spi: i32, atomics: Atomics) -> AOVImage {
    // Width & height always the same as film_width, film_height
    let mut ptr : &mut [f32];
    ignis_get_aov_image(id, &mut ptr);
    make_atomic_aov_image(ptr, w, h, spi, atomics)
}

fn @gpu_get_framebuffer(spi: i32, use_framebuffer: bool, atomics: Atomics) -> AOVImage {
    let (film_pixels, film_width, film_height) = gpu_get_film_data();
    if !use_framebuffer {
        make_empty_aov_image(film_width, film_height)
    } else {
        let framebuffer = make_atomic_aov_image(film_pixels, film_width, film_height, spi, atomics);
        // TODO: Make this configurable!
        attach_no_filter(framebuffer)
    }
}

fn @gpu_traverse_primary(primary: PrimaryStream
                       , scene: SceneTracer
                       , size: i32
                       , min_max: MinMax
                       , acc: Accelerator
                       , gpu_config: GPUKernelConfiguration) -> () {
    let rays = make_ray_stream_reader(primary.rays, 1);
    let hits = make_primary_stream_hit_writer(primary, 1);

    gpu_exec_1d(acc, size, gpu_config.block_size_traversal_primary, |work_item| {
        let gid = work_item.gidx();
        if gid >= size { return() }

        let ray     = rays(gid, 0);
        let mut hit = invalid_hit(ray.tmax);

        if primary.rays.id(gid) != -1 {
            for k in unroll(0, scene.type_count) {
                hit = gpu_traverse_scene(min_max, ray, hit, scene.get(k), false /* any_hit */, 1 /*root*/);
            }
        }
        
        hits(gid, 0, hit);
    });
    acc.sync();
}

fn @gpu_traverse_secondary( secondary: SecondaryStream
                          , scene: SceneTracer
                          , size: i32
                          , min_max: MinMax
                          , acc: Accelerator
                          , gpu_config: GPUKernelConfiguration
                          , config: RenderConfig
                          , framebuffer: AOVImage
                          , is_advanced: bool
                          ) -> () {
    let spi = config.spi;
    gpu_exec_1d(acc, size, gpu_config.block_size_traversal_secondary, |work_item| {
        let gid = work_item.gidx();
        if gid >= size { return() }

        let ray_id = secondary.rays.id(gid);
        if ray_id < 0 { return() }
        let pixel_l = ray_id / spi;
        let pixel   = make_pixelcoord_from_linear(pixel_l, framebuffer.width, framebuffer.height, 0, 0);

        let ray = make_ray_stream_reader(secondary.rays, 1)(gid, 0);
        let mut hit = invalid_hit(ray.tmax);

        for k in unroll(0, scene.type_count) {
            hit = gpu_traverse_scene(min_max, ray, hit, scene.get(k), true /* any_hit */, 1 /*root*/);
            if hit.prim_id >= 0 { break() } // Any hit?
        }

        if is_advanced {
            make_secondary_stream_hit_writer(secondary, 1)(gid, 0, hit); // Just write it to buffer
        } else {
            if hit.prim_id < 0 {
                framebuffer.splat(pixel, make_color(
                    secondary.color_r(gid),
                    secondary.color_g(gid),
                    secondary.color_b(gid),
                    1
                ));
            }
        }
    });
    acc.sync();
}

fn @gpu_hit_shade( acc: Accelerator
                 , gpu_config: GPUKernelConfiguration
                 , shader: MaterialShader
                 , scene: Scene
                 , technique: Technique
                 , config: RenderConfig
                 , payload_info: PayloadInfo
                 , framebuffer: AOVImage
                 , primary: PrimaryStream
                 , secondary: SecondaryStream
                 , first: i32, last: i32) -> () {
    let n = last - first;

    let entities = scene.entities;
    let shapes   = scene.shapes;
    
    let read_primary_ray        = make_ray_stream_reader(primary.rays, 1);
    let read_primary_hit        = make_primary_stream_hit_reader(primary, 1);
    let read_primary_rnd_state  = make_primary_stream_rnd_state_reader(primary, 1);
    let write_primary_ray       = make_ray_stream_writer(primary.rays, 1);
    let write_secondary_ray     = make_ray_stream_writer(secondary.rays, 1);
    let write_primary_rnd_state = make_primary_stream_rnd_state_writer(primary, 1);

    let get_primary_payload   = make_primary_stream_payload_handler(primary, payload_info.primary_count, gpu_config.stream_capacity, 1, false);
    let get_secondary_payload = make_secondary_stream_payload_handler(secondary, payload_info.secondary_count, gpu_config.stream_capacity, 1, false);

    let on_hit    = technique.on_hit;
    let on_shadow = technique.on_shadow;
    let on_bounce = technique.on_bounce;

    let shading_info = make_shading_info(config);

    gpu_exec_1d(acc, n, gpu_config.block_size_hit, |work_item| {
        let i = first + work_item.gidx();
        if i >= last {
            return()
        }

        let primary_payload   = get_primary_payload(i, 0);
        let secondary_payload = get_secondary_payload(i, 0);

        let ray     = read_primary_ray(i, 0);
        let hit     = read_primary_hit(i, 0);
        let ray_id  = primary.rays.id(i);
        let sample  = ray_id % config.spi;
        let pixel_l = ray_id / config.spi;
        let pixel   = make_pixelcoord_from_linear(pixel_l, framebuffer.width, framebuffer.height, 0, 0);

        let rnd = create_random_generator_live(create_random_seed(sample, config.iter, config.frame, pixel.x, pixel.y, config.seed), read_primary_rnd_state(i, 0));

        let entity = @entities(hit.ent_id);
        let shape  = @shapes(entity.shape_id);

        let pmset    = make_standard_pointmapperset(shape, entity);
        let glb_surf = shape.surface_element(ray, hit, pmset);
        
        let ctx = make_surface_shading_context(hit.ent_id, pixel, ray, hit, glb_surf, pmset, shading_info);
        let mat = @shader(ctx);
        if let Option[Color]::Some(color) = @on_hit(ctx, primary_payload, mat) {
            framebuffer.splat(pixel, color);
        }

        match @on_shadow(ctx, rnd, primary_payload, secondary_payload, mat) {
            ShadowRay::Simple(new_ray, color) => {
                write_secondary_ray(i, 0, new_ray);
                secondary.mat_id(i)  = mat.id + 1;
                secondary.color_r(i) = color.r;
                secondary.color_g(i) = color.g;
                secondary.color_b(i) = color.b;
                secondary.rays.id(i) = ray_id;
            },
            ShadowRay::Advanced(new_ray, color, mat_id) => {
                write_secondary_ray(i, 0, new_ray);
                secondary.mat_id(i)  = mat_id + 1;
                secondary.color_r(i) = color.r;
                secondary.color_g(i) = color.g;
                secondary.color_b(i) = color.b;
                secondary.rays.id(i) = ray_id;
            },
            _ => { /* None */
                secondary.rays.id(i) = -1;
            }
        }

        if let Option[Ray]::Some(new_ray) = @on_bounce(ctx, rnd, primary_payload, mat) {
            write_primary_ray(i, 0, new_ray);
            write_primary_rnd_state(i, 0, rnd.get_counter());
        } else {
            primary.rays.id(i) = -1;
        }
    });
}

fn @gpu_hit_shade_handler(acc: Accelerator
                        , gpu_config: GPUKernelConfiguration
                        , atomics: Atomics
                        , shader: MaterialShader
                        , scene: Scene
                        , technique: Technique
                        , config: RenderConfig
                        , payload_info: PayloadInfo
                        , begin: i32
                        , end: i32
                        , use_framebuffer: bool) -> () {    
    let mut primary : PrimaryStream;
    ignis_get_primary_stream_const(0, &mut primary);
    let mut secondary : SecondaryStream;
    ignis_get_secondary_stream_const(0, &mut secondary);

    let framebuffer = gpu_get_framebuffer(config.spi, use_framebuffer, atomics);
    gpu_hit_shade(acc, gpu_config, shader, scene, technique, config, payload_info, framebuffer, primary, secondary, begin, end);
}

// Shade nonhits
fn @gpu_miss_shade( acc: Accelerator
                  , gpu_config: GPUKernelConfiguration
                  , technique: Technique
                  , config: RenderConfig
                  , payload_info: PayloadInfo
                  , framebuffer: AOVImage
                  , primary: PrimaryStream
                  , first: i32, last: i32) -> () {
    let n = last - first;
    
    let read_primary_ray    = make_ray_stream_reader(primary.rays, 1);
    let get_primary_payload = make_primary_stream_payload_handler(primary, payload_info.primary_count, gpu_config.stream_capacity, 1, false);

    let on_miss = technique.on_miss;
    let spi     = config.spi;

    let shading_info = make_shading_info(config);

    gpu_exec_1d(acc, n, gpu_config.block_size_miss, |work_item| {
        let i = first + work_item.gidx();
        if i >= last {
            return()
        }

        let payload = get_primary_payload(i, 0);
        let ray     = read_primary_ray(i, 0);
        let ray_id  = primary.rays.id(i);
        let pixel_l = ray_id / spi;
        let pixel   = make_pixelcoord_from_linear(pixel_l, framebuffer.width, framebuffer.height, 0, 0);

        let ctx = make_miss_shading_context(pixel, ray, shading_info);
        if let Option[Color]::Some(color) = @on_miss(ctx, payload) {
            framebuffer.splat(pixel, color);
        }
        
        primary.rays.id(i) = -1; // Kill ray as it goes to nowhere
    });
}

fn @gpu_miss_shade_handler(acc: Accelerator
                         , gpu_config: GPUKernelConfiguration
                         , atomics: Atomics
                         , technique: Technique
                         , config: RenderConfig
                         , payload_info: PayloadInfo
                         , begin: i32
                         , end: i32
                         , use_framebuffer: bool) -> () {
    let mut primary: PrimaryStream;
    ignis_get_primary_stream_const(0, &mut primary);

    let framebuffer = gpu_get_framebuffer(config.spi, use_framebuffer, atomics);
    gpu_miss_shade(acc, gpu_config, technique, config, payload_info, framebuffer, primary, begin, end);
}

// Handle advanced shadows
fn @gpu_advanced_shadow(is_hit: bool
                      , acc: Accelerator
                      , gpu_config: GPUKernelConfiguration
                      , shader: MaterialShader
                      , technique: Technique
                      , config: RenderConfig
                      , payload_info: PayloadInfo
                      , framebuffer: AOVImage
                      , secondary: SecondaryStream
                      , first: i32, last: i32) -> () {
    let n = last - first;

    let read_secondary_ray    = make_ray_stream_reader(secondary.rays, 1);
    let read_secondary_color  = make_secondary_stream_color_reader(secondary, 1);
    let get_secondary_payload = make_secondary_stream_payload_handler(secondary, payload_info.secondary_count, gpu_config.stream_capacity, 1, false);

    let on_miss    = technique.on_shadow_miss;
    let on_hit     = technique.on_shadow_hit;
    let callback   = if is_hit { on_hit } else { on_miss };
    let block_size = if is_hit { gpu_config.block_size_advanced_shadow_hit } else { gpu_config.block_size_advanced_shadow_miss };

    let spi          = config.spi;
    let shading_info = make_shading_info(config);

    gpu_exec_1d(acc, n, block_size, |work_item| {
        let i = first + work_item.gidx();
        if i >= last { return() }

        let color   = read_secondary_color(i, 0);
        let ray     = read_secondary_ray(i, 0);
        let payload = get_secondary_payload(i, 0);
        let ray_id  = secondary.rays.id(i);
        let pixel_l = ray_id / spi;
        let pixel   = make_pixelcoord_from_linear(pixel_l, framebuffer.width, framebuffer.height, 0, 0);

        let ctx = make_miss_shading_context(pixel, ray, shading_info);
        if let Option[Color]::Some(new_color) = @callback(ctx, shader, payload, color) {
            framebuffer.splat(pixel, new_color);
        }
    });
}

fn @gpu_advanced_shadow_handler(acc: Accelerator
                              , gpu_config: GPUKernelConfiguration
                              , atomics: Atomics
                              , shader: MaterialShader
                              , technique: Technique
                              , config: RenderConfig
                              , payload_info: PayloadInfo
                              , begin: i32
                              , end: i32
                              , use_framebuffer: bool
                              , is_hit: bool) -> () {
    let mut secondary: SecondaryStream;
    ignis_get_secondary_stream_const(0, &mut secondary);

    let framebuffer = gpu_get_framebuffer(config.spi, use_framebuffer, atomics);
    gpu_advanced_shadow(is_hit, acc, gpu_config, shader, technique, config, payload_info, framebuffer, secondary, begin, end);
}

fn @gpu_copy_ray( rays: RayStream
                    , other_rays: RayStream
                    , src_id: i32
                    , dst_id: i32
                    ) -> () {
    other_rays.id(dst_id)    = rays.id(src_id);
    other_rays.org_x(dst_id) = rays.org_x(src_id);
    other_rays.org_y(dst_id) = rays.org_y(src_id);
    other_rays.org_z(dst_id) = rays.org_z(src_id);
    other_rays.dir_x(dst_id) = rays.dir_x(src_id);
    other_rays.dir_y(dst_id) = rays.dir_y(src_id);
    other_rays.dir_z(dst_id) = rays.dir_z(src_id);
    other_rays.tmin(dst_id)  = rays.tmin(src_id);
    other_rays.tmax(dst_id)  = rays.tmax(src_id);
    other_rays.flags(dst_id) = rays.flags(src_id);
}

fn @gpu_copy_primary_ray( primary: PrimaryStream
                    , other_primary: PrimaryStream
                    , src_id: i32
                    , dst_id: i32
                    , keep_hit: bool
                    , payload_count: i32
                    ) -> () {
    gpu_copy_ray(primary.rays, other_primary.rays, src_id, dst_id);
    if keep_hit {
        other_primary.ent_id(dst_id)  = primary.ent_id(src_id);
        other_primary.prim_id(dst_id) = primary.prim_id(src_id);
        other_primary.t(dst_id)       = primary.t(src_id);
        other_primary.u(dst_id)       = primary.u(src_id);
        other_primary.v(dst_id)       = primary.v(src_id);
    }
    other_primary.rnd(dst_id) = primary.rnd(src_id);

    for c in unroll(0, payload_count) {
        other_primary.payload(dst_id*payload_count + c) = primary.payload(src_id*payload_count + c);
    }
}

fn @gpu_copy_secondary_ray( secondary: SecondaryStream
                    , other_secondary: SecondaryStream
                    , src_id: i32
                    , dst_id: i32
                    , payload_count: i32
                    ) -> () {
    gpu_copy_ray(secondary.rays, other_secondary.rays, src_id, dst_id);
    other_secondary.mat_id(dst_id)  = secondary.mat_id(src_id);
    other_secondary.color_r(dst_id) = secondary.color_r(src_id);
    other_secondary.color_g(dst_id) = secondary.color_g(src_id);
    other_secondary.color_b(dst_id) = secondary.color_b(src_id);

    for c in unroll(0, payload_count) {
        other_secondary.payload(dst_id*payload_count + c) = secondary.payload(src_id*payload_count + c);
    }
}

fn @gpu_sort_primary( primary: PrimaryStream
                    , other_primary: PrimaryStream
                    , size: i32
                    , acc: Accelerator
                    , gpu_config: GPUKernelConfiguration
                    , scene: Scene
                    , payload_count: i32
                    , entity_per_material: &[i32]
                    , gpu_tmp:  DeviceBuffer
                    , ray_begins: &mut [i32]
                    , ray_ends: &mut [i32]
                    ) -> () {

    // Note: We could sort based on materials only, but sorting based on entities, 
    // and than collapsing based on materials ensures a better buffer lookup later in the shading stage, due to similar properties grouped together.
    // TODO: This has to be proper evaluated in large scenes, though.
    let num_geometries = scene.num_entities;

    fn @get_entry_arr_id(i: i32) {
        let k = primary.ent_id(i);
        // let k = primary.mat_id(i);
        select(k == InvalidHitId, num_geometries, k)
    }

    // Fill temporary buffer with 0s
    stats::begin_section(stats::Section::GPUSortPrimaryReset);
    gpu_exec_1d(acc, num_geometries + 1, gpu_config.block_size_reset, |work_item| {
        let id = work_item.gidx();
        if id > num_geometries { return() }
        gpu_tmp.store_i32(id, 0);
    });
    acc.sync();
    stats::end_section(stats::Section::GPUSortPrimaryReset);

    // Count number of rays for each geometry
    stats::begin_section(stats::Section::GPUSortPrimaryCount);
    gpu_exec_1d(acc, size, gpu_config.block_size_sort_primary, |work_item| {
        let ray_id = work_item.gidx();
        if ray_id >= size { return() }

        gpu_tmp.add_atomic_i32(get_entry_arr_id(ray_id), 1);
    });
    acc.sync();
    stats::end_section(stats::Section::GPUSortPrimaryCount);

    // Perform a scan on the CPU (there are very few elements to scan)
    // TODO: Try this out on the GPU?
    stats::begin_section(stats::Section::GPUSortPrimaryScan);
    gpu_tmp.copy_to_host(0, num_geometries + 1, ray_ends);
    let mut n = 0;
    for i in range(0, num_geometries + 1) {
        ray_begins(i) = n;
        n += ray_ends(i);
        ray_ends(i) = n;
    }
    gpu_tmp.copy_from_host(0, num_geometries + 1, ray_begins);
    stats::end_section(stats::Section::GPUSortPrimaryScan);

    // Sort rays
    stats::begin_section(stats::Section::GPUSortPrimarySort);
    gpu_exec_1d(acc, size, gpu_config.block_size_sort_primary, |work_item| {
        let src_id = work_item.gidx();
        if src_id >= size { return() }

        let dst_id = gpu_tmp.add_atomic_i32(get_entry_arr_id(src_id), 1);
        gpu_copy_primary_ray(primary, other_primary, src_id, dst_id, true, payload_count);
    });
    acc.sync();
    stats::end_section(stats::Section::GPUSortPrimarySort);

    if num_geometries != scene.num_materials {
        // Collapse entities to materials, because entities are ordered by material while loading
        // The assumption num_materials <= num_entities has to be strictly fulfilled
        stats::begin_section(stats::Section::GPUSortPrimaryCollapse);
        let mut k = 0;
        for i in range(0, scene.num_materials) {
            let s = entity_per_material(i);

            // A material has at least one entity
            let start = ray_begins(k);
            let end   = ray_ends(k + s - 1);
            
            ray_begins(i) = start;
            ray_ends(i)   = end;
            
            k += s;
        }
        stats::end_section(stats::Section::GPUSortPrimaryCollapse);

        // Ensure the "invalids" are propagated
        ray_begins(scene.num_materials) = ray_begins(num_geometries);
        ray_ends(scene.num_materials)   = ray_ends(num_geometries);
    }
}

fn @gpu_sort_secondary(secondary: SecondaryStream
                     , other_secondary: SecondaryStream
                     , size: i32
                     , payload_count: i32
                     , acc: Accelerator
                     , gpu_config: GPUKernelConfiguration
                     , gpu_tmp: DeviceBuffer
                     ) -> (i32, i32) {
    // Init temporary values to zero on the GPU
    gpu_tmp.store_i32_host(0, 0); // Valid count
    gpu_tmp.store_i32_host(1, 0); // Invalid count

    // Count valid rays as a head start for invalid count
    gpu_exec_1d(acc, size, gpu_config.block_size_sort_secondary_simple, |work_item| {
        let src_id = work_item.gidx();
        if src_id >= size { return() }
        if secondary.rays.id(src_id) < 0 { return() } // Skip entries which no shadow ray requested

        if secondary.mat_id(src_id) < 0 {
            gpu_tmp.add_atomic_i32(1, 1);
        }
    });
    acc.sync();

    // Sort rays
    gpu_exec_1d(acc, size, gpu_config.block_size_sort_secondary_simple, |work_item| {
        let src_id = work_item.gidx();
        if src_id >= size { return() }
        if secondary.rays.id(src_id) < 0 { return() } // Skip entries which no shadow ray requested

        let dst_id = if secondary.mat_id(src_id) < 0 {
            gpu_tmp.add_atomic_i32(0, 1)
        } else {
            gpu_tmp.add_atomic_i32(1, 1)
        };

        gpu_copy_secondary_ray(secondary, other_secondary, src_id, dst_id, payload_count);
    });
    acc.sync();

    // Get number of valids
    let valid_entries = gpu_tmp.load_i32_host(0);
    let entries       = gpu_tmp.load_i32_host(1);
    (valid_entries, entries)
}

fn @gpu_sort_secondary_with_materials( secondary: SecondaryStream
                                     , other_secondary: SecondaryStream
                                     , size: i32
                                     , acc: Accelerator
                                     , gpu_config: GPUKernelConfiguration
                                     , scene: Scene
                                     , payload_count: i32
                                     , gpu_tmp: DeviceBuffer
                                     , ray_begins: &mut [i32]
                                     , ray_ends: &mut [i32]
                                     ) -> (i32, i32) {
    let num_materials = scene.num_materials;
    let limit         = num_materials * 2;

    fn @map_id(i:i32) -> i32 {
        let id = secondary.mat_id(i); // Is +1
        select(id < 0, -id, num_materials + id) - 1
    }

    // Fill temporary buffer with 0s
    gpu_exec_1d(acc, limit, gpu_config.block_size_reset, |work_item| {
        let id = work_item.gidx();
        if id >= limit { return() }
        gpu_tmp.store_i32(id, 0);
    });

    // Count number of rays for each geometry
    gpu_exec_1d(acc, size, gpu_config.block_size_sort_secondary_materials, |work_item| {
        let ray_id = work_item.gidx();
        if ray_id >= size { return() }

        gpu_tmp.add_atomic_i32(map_id(ray_id), 1);
    });
    acc.sync();

    // Perform a scan on the CPU (there are very few elements to scan)
    gpu_tmp.copy_to_host(0, limit, ray_ends);

    let mut n = 0;
    for i in range(0, num_materials) {
        ray_begins(i) = n;
        n += ray_ends(i);
        ray_ends(i) = n;
    }
    let count = n;
    for i in range(num_materials, limit) {
        ray_begins(i) = n;
        n += ray_ends(i);
        ray_ends(i) = n;
    }

    gpu_tmp.copy_from_host(0, limit, ray_begins);

    // Sort rays
    gpu_exec_1d(acc, size, gpu_config.block_size_sort_secondary_materials, |work_item| {
        let src_id = work_item.gidx();
        if src_id >= size { return() }

        let dst_id = gpu_tmp.add_atomic_i32(map_id(src_id), 1);
        gpu_copy_secondary_ray(secondary, other_secondary, src_id, dst_id, payload_count);
    });
    acc.sync();

    (count, n)
}

fn @gpu_generate_rays( primary: PrimaryStream
                     , acc: Accelerator
                     , gpu_config: GPUKernelConfiguration
                     , emitter: RayEmitter
                     , config: RenderConfig
                     , payload_info: PayloadInfo
                     , gen_info: GenerateRayInfo
                     , film_width: i32
                     , film_height: i32
                     ) -> i32 {
    let spi          = config.spi;
    let current_size = gen_info.size;
    let first_ray_id = gen_info.next_id;
    let first_dst_id = current_size;
    let film_size    = film_width * film_height;
    let num_rays     = min(spi * film_size - first_ray_id, gpu_config.stream_capacity - first_dst_id);
    let film_div     = make_fast_div(film_width as u32);

    let ray_ids   = primary.rays.id;
    let write_ray = make_ray_stream_writer(primary.rays, 1);
    let write_rnd = make_primary_stream_rnd_state_writer(primary, 1);
    let write_id  = @ |i: i32, _: i32, id2: i32| ray_ids(i) = id2;

    let get_payload = make_primary_stream_payload_handler(primary, payload_info.primary_count, gpu_config.stream_capacity, 1, false);

    if num_rays <= 0 { /* TODO: Add error message! */ return(0) }

    gpu_exec_1d(acc, num_rays, gpu_config.block_size_generate_rays, |work_item| {
        let gid = work_item.gidx();
        if gid >= num_rays {
            return()
        }

        let ray_id = first_ray_id + gid;
        let dst_id = first_dst_id + gid;
        let sample = ray_id % spi;
        let pixel  = ray_id / spi;
        let y = fast_div(film_div, pixel as u32) as i32;
        let x = pixel - y * film_width;
        let payload = get_payload(dst_id, 0);

        let (ray, rnd) = @emitter(sample, x, y, film_width, film_height, payload);
        if let Option[Ray]::Some(actual_ray) = ray {
            write_ray(dst_id, 0, actual_ray);
            write_rnd(dst_id, 0, rnd.get_counter());
            write_id(dst_id, 0, ray_id);
        } else {
            write_id(dst_id, 0, -1);
        }
    });
    acc.sync();

    current_size + num_rays
}

fn @gpu_generate_rays_handler(acc: Accelerator
                            , gpu_config: GPUKernelConfiguration
                            , emitter: RayEmitter
                            , config: RenderConfig
                            , payload_info: PayloadInfo
                            , gen_info: GenerateRayInfo
                            ) -> i32 {
    let work_info = get_work_info();

    let mut primary: PrimaryStream;
    ignis_get_primary_stream(0, &mut primary, gpu_config.stream_capacity);

    gpu_generate_rays(primary, acc, gpu_config, emitter, config, payload_info, gen_info, work_info.width, work_info.height)
}

fn @gpu_compact_primary( primary: PrimaryStream
                       , other_primary: PrimaryStream
                       , size: i32
                       , payload_count: i32
                       , acc: Accelerator
                       , gpu_config: GPUKernelConfiguration
                       , gpu_tmp: DeviceBuffer
                       ) -> i32 {
    // reset temporary memory
    gpu_tmp.store_i32_host(0, 0);

    // Compact primary rays into another queue
    gpu_exec_1d(acc, size, gpu_config.block_size_compact_primary, |work_item| {
        let src_id = work_item.gidx();
        if src_id >= size { return() }

        let ray_id = primary.rays.id(src_id);
        if ray_id < 0 { return() }

        let dst_id = gpu_tmp.add_atomic_i32(0, 1);
        gpu_copy_primary_ray(primary, other_primary, src_id, dst_id, false, payload_count);
    });
    acc.sync();

    gpu_tmp.load_i32_host(0)
}

fn @gpu_swap_primary_streams(a: &mut PrimaryStream, b: &mut PrimaryStream) -> () {
    swap(a, b);
    // We have to make sure that other parts of the runtime also swap it
    ignis_gpu_swap_primary_streams(); 
}

fn @gpu_swap_secondary_streams(a: &mut SecondaryStream, b: &mut SecondaryStream) -> () {
    swap(a, b);
    // We have to make sure that other parts of the runtime also swap it
    ignis_gpu_swap_secondary_streams(); 
}

fn @gpu_temporary_counter_size(scene: Scene) = round_up(max(32, max(scene.num_entities + 1, (scene.num_materials + 1) * 2)), 4);

fn @gpu_trace( acc: Accelerator
             , gpu_config: GPUKernelConfiguration
             , scene: Scene
             , pipeline: Pipeline
             , config: RenderConfig
             , payload_info: PayloadInfo
             , likely: fn (bool) -> bool
             , accb: DeviceBufferAccessor
             ) -> () {
    let work_info = get_work_info();

    let mut primary:         PrimaryStream;
    let mut other_primary:   PrimaryStream;
    let mut secondary:       SecondaryStream;
    let mut other_secondary: SecondaryStream;
    ignis_get_primary_stream(  0, &mut primary,         gpu_config.stream_capacity);
    ignis_get_primary_stream(  1, &mut other_primary,   gpu_config.stream_capacity);
    ignis_get_secondary_stream(0, &mut secondary,       gpu_config.stream_capacity);
    ignis_get_secondary_stream(1, &mut other_secondary, gpu_config.stream_capacity);

    // These two buffers are on the host only
    let mut temp_host : TemporaryStorageHost;
    ignis_get_temporary_storage_host(&mut temp_host);

    let temp_counter = gpu_request_buffer("__dev_counter", gpu_temporary_counter_size(scene), accb);

    let mut id = 0;
    let mut current_size = 0;
    let num_rays = config.spi * work_info.width * work_info.height;
    while id < num_rays || current_size > 0 {
        // Regenerate rays
        if current_size < gpu_config.stream_capacity && id < num_rays {
            let before_s = current_size;
            current_size = pipeline.on_generate(GenerateRayInfo{ next_id=id, size=current_size, xmin=0, ymin=0, xmax=work_info.width, ymax=work_info.height });
            let added    = current_size - before_s;
            id += added;
            stats::add_quantity(stats::Quantity::CameraRayCount, added);
        }

        // Special case: No entities to intersect
        if scene.num_entities == 0 {
            pipeline.on_miss_shade(0, current_size);
            current_size = 0;
            acc.sync();
            continue()
        }

        // Traverse primary rays
        pipeline.on_traverse_primary(current_size);

        // Sort rays by entity
        stats::begin_section(stats::Section::GPUSortPrimary);
        gpu_sort_primary(primary, other_primary, current_size, acc, gpu_config, scene, payload_info.primary_count, temp_host.entity_per_material, temp_counter, temp_host.ray_begins, temp_host.ray_ends);
        gpu_swap_primary_streams(&mut primary, &mut other_primary);
        stats::end_section(stats::Section::GPUSortPrimary);

        // Shade rays
        let mut first = 0;
        for mat_id in range(0, scene.num_materials) {
            let last = temp_host.ray_ends(mat_id);
            if first < last {
                pipeline.on_hit_shade(mat_id, first, last);
                // acc.sync(); // Uncomment this for debugging
                first = last;
            }
        }

        // Shade non-hits as well
        let last = temp_host.ray_ends(scene.num_materials);
        if first < last {
            pipeline.on_miss_shade(first, last);
            // Do not set first as last (to make sure they drop out)
        }

        current_size       = first;
        let secondary_size = first;
        acc.sync();

        if likely(first > 0) {
            pipeline.on_traverse_secondary(secondary_size);

            // Trace secondary rays
            if work_info.advanced_shadows {                
                // Secondary stream is modified, sort it to have valid shadows first, invalids last
                stats::begin_section(stats::Section::GPUSortSecondary);
                let (valid_count, count) = gpu_sort_secondary(secondary, other_secondary, secondary_size, payload_info.secondary_count, acc, gpu_config, temp_counter);
                gpu_swap_secondary_streams(&mut secondary, &mut other_secondary);
                stats::end_section(stats::Section::GPUSortSecondary);

                if valid_count != 0 {
                    // Call valids (miss)
                    pipeline.on_advanced_shadow(0, 0, valid_count, false);
                }

                if valid_count < count {
                    // Call invalids (hits)
                    pipeline.on_advanced_shadow(0, valid_count, count, true);
                }
                acc.sync();
            } else if work_info.advanced_shadows_with_materials {                
                // Secondary stream is modified, sort it to have valid shadows first, invalids last
                stats::begin_section(stats::Section::GPUSortSecondary);
                let (valid_count, count) = gpu_sort_secondary_with_materials(secondary, other_secondary, secondary_size, acc, gpu_config, scene, payload_info.secondary_count, temp_counter, temp_host.ray_begins, temp_host.ray_ends);
                gpu_swap_secondary_streams(&mut secondary, &mut other_secondary);
                stats::end_section(stats::Section::GPUSortSecondary);

                let mut sfirst = 0;
                if valid_count != 0 {
                    // Call valids (miss)
                    for mat_id in range(0, scene.num_materials) {
                        let slast = temp_host.ray_ends(mat_id);
                        if sfirst < slast {
                            pipeline.on_advanced_shadow(mat_id, sfirst, slast, false);
                            sfirst = slast;
                        }
                    }
                }

                if valid_count < count {
                    // Call invalids (hits)
                    for mat_id in range(0, scene.num_materials) {
                        let slast = temp_host.ray_ends(scene.num_materials + mat_id);
                        if sfirst < slast {
                            pipeline.on_advanced_shadow(mat_id, sfirst, slast, true);
                            sfirst = slast;
                        }
                    }
                }
                acc.sync();
            }
            stats::add_quantity(stats::Quantity::ShadowRayCount, secondary_size);

            // Compact primary rays
            stats::begin_section(stats::Section::GPUCompactPrimary);
            current_size = gpu_compact_primary(primary, other_primary, current_size, payload_info.primary_count, acc, gpu_config, temp_counter);
            gpu_swap_primary_streams(&mut primary, &mut other_primary);
            stats::end_section(stats::Section::GPUCompactPrimary);
            stats::add_quantity(stats::Quantity::BounceRayCount, current_size);
        }
    }
}

// GPU device ----------------------------------------------------------------------

fn @make_gpu_device( dev_id: i32
                   , config: RenderConfig
                   , acc: Accelerator
                   , gpu_config: GPUKernelConfiguration
                   , min_max: MinMax
                   , accb: DeviceBufferAccessor
                   , accs: ShallowBufferAccessor
                   , atomics: Atomics
                   , is_nvvm: bool
                   ) = Device {
    id    = dev_id,
    trace = @ |scene, pipeline, payload_info| {
        gpu_trace(
            acc,
            gpu_config,
            scene,
            pipeline,
            config,
            payload_info,
            if is_nvvm { nvvm_likely } else { null_likely },
            accb
        )
    },
    generate_rays = @ | emitter, payload_info, gen_info | -> i32 {
        gpu_generate_rays_handler(acc, gpu_config, emitter, config, payload_info, gen_info)
    },
    handle_traversal_primary = @ | scene_tracer, size | {
        let mut primary: PrimaryStream;
        ignis_get_primary_stream_const(0, &mut primary);

        gpu_traverse_primary(primary, scene_tracer, size, min_max, acc, gpu_config);
    },
    handle_traversal_secondary = @ | scene_tracer, size, is_advanced, use_framebuffer | {
        let mut secondary: SecondaryStream;
        ignis_get_secondary_stream_const(0, &mut secondary);

        let framebuffer = gpu_get_framebuffer(config.spi, use_framebuffer, atomics);
        gpu_traverse_secondary(secondary, scene_tracer, size, min_max, acc, gpu_config, config, framebuffer, is_advanced);
    },
    handle_miss_shader = @ | technique, payload_info, first, last, use_framebuffer | {
        gpu_miss_shade_handler(acc, gpu_config, atomics, technique, config, payload_info, first, last, use_framebuffer);
    },
    handle_hit_shader = @ | shader, scene, technique, payload_info, first, last, use_framebuffer | {
        gpu_hit_shade_handler(acc, gpu_config, atomics, shader, scene, technique, config, payload_info, first, last, use_framebuffer);
    },
    handle_advanced_shadow_shader = @ | shader, technique, payload_info, first, last, use_framebuffer, is_hit | {
        gpu_advanced_shadow_handler(acc, gpu_config, atomics, shader, technique, config, payload_info, first, last, use_framebuffer, is_hit);
    },
    get_traversal_handler_multiple = @ | prims | make_gpu_scene_local_handler_multiple(prims, min_max), 
    sync = @ || acc.sync(),
    parallel_range = @ |body| {
        @|start, end| {
            let size = end - start;
            if size > 0 {
                fn @run_1d(block_size: i32) {
                    gpu_exec_1d(acc, size, block_size, |work_item| {
                        let gid = work_item.gidx();
                        if gid >= size { return() }
                        @ body(gid + start)
                    })
                }

                if size <= gpu_config.block_size_parallel_range_1d { 
                    run_1d(gpu_config.block_size_parallel_range_1d / 2)
                } else { 
                    run_1d(gpu_config.block_size_parallel_range_1d)
                }
            }
        }
    },
    parallel_range_2d = @ |body| {
        @|start_x, end_x, start_y, end_y| {
            let size_x = end_x - start_x;
            let size_y = end_y - start_y;

            if size_x > 0 && size_y > 0 {
                fn @run_2d(block_size:i32) {
                    let grid  = (round_up(size_x, block_size), round_up(size_y, block_size), 1);
                    let block = (block_size, block_size, 1);
                    acc.exec( @|work_item| {
                        let (sw_t_x, sw_t_y) = gpu_swizzle_2d_id(8, work_item);
                        if sw_t_x >= size_x || sw_t_y >= size_y { return() }
                        
                        @ body(sw_t_x + start_x, sw_t_y + start_y)
                    })(grid, block);
                }

                if size_x <= gpu_config.block_size_parallel_range_2d && size_y <= gpu_config.block_size_parallel_range_2d { 
                    run_2d(gpu_config.block_size_parallel_range_2d / 2)
                } else { 
                    run_2d(gpu_config.block_size_parallel_range_2d)
                }
            }
        }
    },
    parallel_reduce_i32     = @|n, elem, op| reduce[i32](make_gpu_parallel_reduce_handler(acc, gpu_config, accb), n, elem, op),
    parallel_reduce_f32     = @|n, elem, op| reduce[f32](make_gpu_parallel_reduce_handler(acc, gpu_config, accb), n, elem, op),
    parallel_reduce_handler = make_gpu_parallel_reduce_handler(acc, gpu_config, accb),
    get_device_buffer_accessor  = @|| accb,
    get_shallow_buffer_accessor = @|| accs,
    load_scene_bvh = @|prim_type| {
        let mut nodes: &[Node2];
        let mut objs:  &[EntityLeaf1];
        ignis_load_bvh2_ent(prim_type, &mut nodes, &mut objs);
        make_gpu_bvh2_ent(nodes, objs, accs)
    },
    load_dyntable = @ |name| -> DynTable {
        let mut table: DynTableData;
        ignis_load_dyntable(name, &mut table);
        make_dyntable(table, accs)
    },
    load_fixtable = @ |name| -> ShallowBuffer {
        let mut ptr      : &[u8];
        let mut bytesize : i32;
        ignis_load_fixtable(name, &mut ptr, &mut bytesize);
        accs(ptr as &[f32], (bytesize as i64 / sizeof[i32]()) as i32 /* Byte to unit */)
    },
    load_image = @ |filename, channel_count| {
        let mut pixel_data : &[f32];
        let mut width      : i32;
        let mut height     : i32;
        ignis_load_image(filename, &mut pixel_data, &mut width, &mut height, channel_count);

        let stride = width; // Drop mutable attribute
        let q = pixel_data as &addrspace(1)[f32];
        if channel_count == 1 {
            make_image_mono(if is_nvvm { @ |x, y| nvvm_ldg_f32(&q(y * stride + x)) } 
                            else { @ |x, y| q(y * stride + x) },
                            width, height)
        } else {
            make_image_rgba32(if is_nvvm { @ |x, y| nvvm_load_vec4(q, y * stride + x) } 
                              else { @ |x, y| amdgpu_load_vec4(q, y * stride + x) },
                              width, height)
        }
    },
    load_image_by_id = @ |id, channel_count| {
        let mut pixel_data : &[f32];
        let mut width      : i32;
        let mut height     : i32;
        ignis_load_image_by_id(id, &mut pixel_data, &mut width, &mut height, channel_count);

        let stride = width; // Drop mutable attribute
        let q = pixel_data as &addrspace(1)[f32];
        if channel_count == 1 {
            make_image_mono(if is_nvvm { @ |x, y| nvvm_ldg_f32(&q(y * stride + x)) } 
                            else { @ |x, y| q(y * stride + x) },
                            width, height)
        } else {
            make_image_rgba32(if is_nvvm { @ |x, y| nvvm_load_vec4(q, y * stride + x) } 
                              else { @ |x, y| amdgpu_load_vec4(q, y * stride + x) },
                              width, height)
        }
    },
    load_packed_image = @ |filename, channel_count, is_linear| {
        let mut pixel_data : &[u8];
        let mut width      : i32;
        let mut height     : i32;
        ignis_load_packed_image(filename, &mut pixel_data, &mut width, &mut height, channel_count, is_linear);

        let stride = width; // Drop mutable attribute
        if channel_count == 1 {
            let q = pixel_data as &addrspace(1)[u8];
            make_image_mono(if is_nvvm { @ |x, y| image_mono_unpack(nvvm_ldg_u8(&(q(y * stride + x)))) }
                            else { @ |x, y| image_mono_unpack(q(y * stride + x)) },
                            width, height)
        } else {
            let hint_opaque = channel_count == 3;
            let q = pixel_data as &addrspace(1)[i32];
            make_image_rgba32(if is_nvvm { @ |x, y| image_rgba_unpack(bitcast[u32](nvvm_ldg_i32(&(q(y * stride + x)))), hint_opaque) }
                              else { @ |x, y| image_rgba_unpack(bitcast[u32](q(y * stride + x)), hint_opaque) },
                              width, height)
        }
    },
    load_packed_image_by_id = @ |id, channel_count, is_linear| {
        let mut pixel_data : &[u8];
        let mut width      : i32;
        let mut height     : i32;
        ignis_load_packed_image_by_id(id, &mut pixel_data, &mut width, &mut height, channel_count, is_linear);

        let stride = width; // Drop mutable attribute
        if channel_count == 1 {
            let q = pixel_data as &addrspace(1)[u8];
            make_image_mono(if is_nvvm { @ |x, y| image_mono_unpack(nvvm_ldg_u8(&(q(y * stride + x)))) }
                            else { @ |x, y| image_mono_unpack(q(y * stride + x)) },
                            width, height)
        } else {
            let hint_opaque = channel_count == 3;
            let q = pixel_data as &addrspace(1)[i32];
            make_image_rgba32(if is_nvvm { @ |x, y| image_rgba_unpack(bitcast[u32](nvvm_ldg_i32(&(q(y * stride + x)))), hint_opaque) }
                              else { @ |x, y| image_rgba_unpack(bitcast[u32](q(y * stride + x)), hint_opaque) },
                              width, height)
        }
    },
    load_aov_image = @ |id, spi| {
        let work_info = get_work_info();
        gpu_get_aov_image(id, work_info.width, work_info.height, spi, atomics)
    },
    load_rays = @ || {
        let mut rays: &[StreamRay]; // TODO: Alignment?
        ignis_load_rays(&mut rays);
        rays
    },
    load_host_buffer       = load_cpu_buffer,
    load_host_buffer_by_id = load_cpu_buffer_by_id,
    load_buffer = @ |filename| {
        let mut ptr      : &[u8];
        let mut bytesize : i32;
        ignis_load_buffer(filename, &mut ptr, &mut bytesize);
        accb(ptr as &[f32], (bytesize as i64 / sizeof[i32]()) as i32 /* Byte to unit */)
    },
    load_buffer_by_id = @ |id| {
        let mut ptr      : &[u8];
        let mut bytesize : i32;
        ignis_load_buffer_by_id(id, &mut ptr, &mut bytesize);
        accb(ptr as &[f32], (bytesize as i64 / sizeof[i32]()) as i32 /* Byte to unit */)
    },
    request_buffer = @ |name, size, flags| {
        let mut ptr : &[u8];
        ignis_request_buffer(name, &mut ptr, size * sizeof[i32]() as i32, flags);
        accb(ptr as &[f32], size)
    },
    make_buffer_view = accs,
    dump_buffer = @ |id, filename| ignis_dbg_dump_buffer(id, filename),
    request_debug_output = @|| {
        let mut ptr : &[u8];
        let size = 4096;
        ignis_request_buffer("__dbg_output", &mut ptr, size * sizeof[i32]() as i32, 0);
        let buffer = accb(ptr as &[f32], size);
        make_debug_output(buffer)
    },
};

fn @make_default_gpu_kernel_config() = GPUKernelConfiguration {
    block_size_traversal_primary        = 64,
    block_size_traversal_secondary      = 64,
    block_size_hit                      = 64,
    block_size_miss                     = 128,
    block_size_advanced_shadow_hit      = 64,
    block_size_advanced_shadow_miss     = 128,
    block_size_generate_rays            = 64,
    block_size_sort_primary             = 1024,
    block_size_sort_secondary_simple    = 1024,
    block_size_sort_secondary_materials = 1024,
    block_size_compact_primary          = 1024,
    block_size_reset                    = 1024,
    block_size_parallel_range_1d        = 512,
    block_size_parallel_range_2d        = 32,
    block_size_parallel_reduce          = 512,
    stream_capacity                     = 1024 * 1024,
};

fn @make_nvvm_device(dev: i32, config: RenderConfig, gpu_config: GPUKernelConfiguration) -> Device {
    let dev_id  = runtime_device(1, dev);
    let atomics = Atomics {
        add_global_i32 = @ |p, i| nvvm_atomic_add_global_i32(p as &mut addrspace(1)i32, i),
        add_global_f32 = @ |p, i| nvvm_atomic_add_global_f32(p as &mut addrspace(1)f32, i),
        min_global_i32 = @ |p, i| nvvm_atomic_min_global_i32(p as &mut addrspace(1)i32, i),
        max_global_i32 = @ |p, i| nvvm_atomic_max_global_i32(p as &mut addrspace(1)i32, i),
        add_shared_i32 = @ |p, i| nvvm_atomic_add_shared(p, i),
        add_shared_f32 = @ |p, i| atomic_p3(11:u32, p, i, 2:u32, "")
    };
    let accessor = DeviceBufferGlobalElementAccessor {
        load_f32  = @|p: &addrspace(1)[f32], i: i32| nvvm_ldg_f32(&(p(i))),
        load_i32  = @|p: &addrspace(1)[i32], i: i32| nvvm_ldg_i32(&(p(i))),
        load_vf32 = @|p: &addrspace(1)[f32], i: i32| {
            let v = nvvm_ldg4_f32(&(&p(i) as &addrspace(1)[simd[f32 * 4]](0)));
            (v(0), v(1), v(2), v(3))
        },
        load_vi32 = @|p: &addrspace(1)[i32], i: i32| {
            let v = nvvm_ldg4_i32(&(&p(i) as &addrspace(1)[simd[i32 * 4]](0)));
            (v(0), v(1), v(2), v(3))
        }
    };

    make_gpu_device(
        dev_id,
        config,
        nvvm_accelerator(dev),
        gpu_config,
        make_default_min_max(), //make_nvvm_min_max(), // The NVVM min_max stuff seems to be slow compared to the default one
        @ |ptr, size| make_gpu_buffer(dev_id, ptr as &addrspace(1)[f32], size, atomics, accessor),
        @ |ptr, size| make_gpu_shallow_buffer(ptr as &addrspace(1)[f32], size, accessor),
        atomics,
        true
    )
}

fn @make_amdgpu_device(dev: i32, config: RenderConfig, gpu_config: GPUKernelConfiguration, ) -> Device {
    let dev_id  = runtime_device(3, dev);
    let atomics = Atomics {
        add_global_i32 = @ |p, i| amdgcn_atomic_add_global_i32(p as &mut addrspace(1)i32, i),
        add_global_f32 = @ |p, i| amdgcn_atomic_add_global_f32(p as &mut addrspace(1)f32, i),
        min_global_i32 = @ |p, i| amdgcn_atomic_min_global_i32(p as &mut addrspace(1)i32, i),
        max_global_i32 = @ |p, i| amdgcn_atomic_max_global_i32(p as &mut addrspace(1)i32, i),
        add_shared_i32 = @ |p, i| amdgcn_atomic_add_shared(p, i),
        add_shared_f32 = @ |p, i| atomic_p3(11:u32, p, i, 2:u32, "wavefront")
    };
    let accessor = DeviceBufferGlobalElementAccessor {
        load_f32  = @|p: &addrspace(1)[f32], i:i32| p(i),
        load_i32  = @|p: &addrspace(1)[i32], i:i32| p(i),
        load_vf32 = @|p: &addrspace(1)[f32], i:i32| {
            let v = (&p(i) as &addrspace(1)[simd[f32 * 4]])(0);
            (v(0), v(1), v(2), v(3))
        },
        load_vi32 = @|p: &addrspace(1)[i32], i:i32| {
            let v = (&p(i) as &addrspace(1)[simd[i32 * 4]])(0);
            (v(0), v(1), v(2), v(3))
        }
    };

    make_gpu_device(
        dev_id,
        config,
        amdgpu_hsa_accelerator(dev), // TODO: Add support for PAL
        gpu_config,
        make_default_min_max(), //make_amdgpu_min_max(),
        @ |ptr, size| make_gpu_buffer(dev_id, ptr as &addrspace(1)[f32], size, atomics, accessor),
        @ |ptr, size| make_gpu_shallow_buffer(ptr as &addrspace(1)[f32], size, accessor),
        atomics,
        false
    )
}
