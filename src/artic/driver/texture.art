struct BorderHandling {
    horz: fn (i32, i32) -> i32,
    vert: fn (i32, i32) -> i32
}

type Texture     = fn (ShadingContext) -> Color;
type ImageFilter = fn (Image, BorderHandling, Vec2) -> Color;

fn @make_clamp_border() -> BorderHandling {
    fn @clamp_(x: i32, w: i32) = clamp(x, 0, w-1);
    BorderHandling {
        horz = clamp_,
        vert = clamp_
    }
}

fn @make_repeat_border() -> BorderHandling {
    fn @repeat_(x: i32, w: i32) {
        let t = x % w;
        select(t < 0, t+w, t)
    }
    BorderHandling {
        horz = repeat_,
        vert = repeat_
    }
}

fn @make_mirror_border() -> BorderHandling {
    fn @mirror_(x: i32, w: i32) {
        let t = select(x < 0, -1-x, x);
        let i = t / w;
        let k = t - i * w;
        select((i & 1) == 0, /* odd */ w - 1 - k, /* even */ k)
    };

    BorderHandling {
        horz = mirror_,
        vert = mirror_
    }
}

fn @make_split_border(border_u: BorderHandling, border_v: BorderHandling) = BorderHandling {
    horz = border_u.horz,
    vert = border_v.vert
};

struct ImageTexelPoint {
    ix: i32,
    iy: i32,
    fx: f32,
    fy: f32
}

fn @map_uv_to_image_pixel(img: Image, uv: Vec2) -> ImageTexelPoint {
    // Edge samples are exactly on border (sample_border = 1 on OpenImageIO)
    //let u = uv.x * (img.width  - 1) as f32;
    //let v = uv.y * (img.height - 1) as f32;
    
    // Texels are on the middle of each ~pixel~
    let u = uv.x * img.width  as f32 - 0.5;
    let v = uv.y * img.height as f32 - 0.5;
    
    ImageTexelPoint {
        ix = math_builtins::floor(u) as i32,
        iy = math_builtins::floor(v) as i32,
        fx = math::fract(u),
        fy = math::fract(v),
    }
}

fn @make_nearest_filter() -> ImageFilter {
    @ |img, border, uv| {
        let texel = map_uv_to_image_pixel(img, uv);
        img.pixels(
            border.horz(texel.ix, img.width ),
            border.vert(texel.iy, img.height))
    }
}

fn @make_bilinear_filter() -> ImageFilter {
    @ |img, border, uv| {
        let texel = map_uv_to_image_pixel(img, uv);
        let x0 = border.horz(texel.ix + 0, img.width );
        let y0 = border.vert(texel.iy + 0, img.height);
        let x1 = border.horz(texel.ix + 1, img.width );
        let y1 = border.vert(texel.iy + 1, img.height);

        let p00 = img.pixels(x0, y0);
        let p10 = img.pixels(x1, y0);
        let p01 = img.pixels(x0, y1);
        let p11 = img.pixels(x1, y1);

        let interp = @ |x00: f32, x10: f32, x01: f32, x11: f32| lerp(lerp(x00, x10, texel.fx), lerp(x01, x11, texel.fx), texel.fy);
        make_color(interp(p00.r, p10.r, p01.r, p11.r),
                   interp(p00.g, p10.g, p01.g, p11.g),
                   interp(p00.b, p10.b, p01.b, p11.b),
                   interp(p00.a, p10.a, p01.a, p11.a))
    }
}
