// Creates a purely diffuse BSDF
fn @make_lambertian_bsdf(surf: SurfaceElement, kd: Color) = Bsdf {
    eval   = @ |in_dir, _| color_mulf(kd, positive_cos(in_dir, surf.local.col(2)) * flt_inv_pi),
    pdf    = @ |in_dir, _| cosine_hemisphere_pdf(positive_cos(in_dir, surf.local.col(2))),
    sample = @ |rnd, _, _| {
        let sample = sample_cosine_hemisphere(rnd.next_f32(), rnd.next_f32());
        let gdir   = mat3x3_mul(surf.local, sample.dir);
        make_bsdf_sample(gdir, sample.pdf, kd, 1)
    },
    is_specular = false
};

fn @make_lambertian_transmission_bsdf(surf: SurfaceElement, kd: Color) = Bsdf {
    eval   = @ |in_dir, _| color_mulf(kd, -negative_cos(in_dir, surf.local.col(2)) * flt_inv_pi),
    pdf    = @ |in_dir, _| cosine_hemisphere_pdf(-negative_cos(in_dir, surf.local.col(2))),
    sample = @ |rnd, _, _| {
        let sample = sample_cosine_hemisphere(rnd.next_f32(), rnd.next_f32());
        let gdir   = mat3x3_mul(surf.local, sample.dir);
        make_bsdf_sample(vec3_neg(gdir), sample.pdf, kd, 1)
    },
    is_specular = false
};

//--------------------------------------
// Creates a two-sided BSDF based on orennayar
fn @make_orennayar_bsdf(surf: SurfaceElement, alpha: f32, kd: Color) -> Bsdf {
    let a2 = alpha * alpha;
    let eval = @ |in_dir : Vec3, out_dir : Vec3| {
        let p1 = positive_cos(in_dir,  surf.local.col(2));
        let p2 = positive_cos(out_dir, surf.local.col(2));
        let s  = -p1 * p2 + positive_cos(out_dir, in_dir);
        let t  = if s <= flt_eps { 1 } else { math_builtins::fmax(flt_eps, math_builtins::fmax(p1, p2)) };

        let A = 1 - 0.5 * a2 / (a2 + 0.33);
        let B = 0.45 * a2 / (a2 + 0.09);
        let C = 0.17 * a2 / (a2 + 0.13); // Correction term
        color_mulf(color_add(color_mulf(kd, (A + (B * s / t)) / flt_pi), color_mul(kd, color_mulf(kd, C / flt_pi))), p1)
    };

    Bsdf {
        eval   = eval,
        pdf    = @ |in_dir, _| cosine_hemisphere_pdf(positive_cos(in_dir, surf.local.col(2))),
        sample = @ |rnd, out_dir, _| {
            let sample = sample_cosine_hemisphere(rnd.next_f32(), rnd.next_f32());
            let gdir   = mat3x3_mul(surf.local, sample.dir);
            make_bsdf_sample(gdir, sample.pdf, color_mulf(eval(gdir, out_dir), 1 / sample.pdf), 1)
        },
        is_specular = false
    }
}

fn @make_diffuse_bsdf(surf: SurfaceElement, alpha: f32, kd: Color) -> Bsdf {
    if ?alpha && alpha <= flt_eps {
        make_lambertian_bsdf(surf, kd)
    } else {
        make_orennayar_bsdf(surf, alpha, kd)
    }
}