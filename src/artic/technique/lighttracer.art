struct LTRayPayload {
    contrib: Color,
    depth:   i32,
    eta:     f32,
}

struct LTSecondaryPayload {
    pixel: Vec2
}

fn @write_ltraypayload(payload: RayPayload, lt: LTRayPayload) -> () {
    payload.set(0, lt.contrib.r);
    payload.set(1, lt.contrib.g);
    payload.set(2, lt.contrib.b);
    payload.set(3, lt.depth as f32);
    payload.set(4, lt.eta);
}

fn @unwrap_ltraypayload(payload: RayPayload) = LTRayPayload {
    contrib = make_color(payload.get(0), payload.get(1), payload.get(2), 1),
    depth   = payload.get(3) as i32,
    eta     = payload.get(4)
};

fn @write_ltsecondarypayload(payload: RayPayload, lt: LTSecondaryPayload) -> () {
    payload.set(0, lt.pixel.x);
    payload.set(1, lt.pixel.y);
}

fn @unwrap_ltsecondarypayload(payload: RayPayload) = LTSecondaryPayload {
    pixel = make_vec2(payload.get(0), payload.get(1)),
};

fn @make_lt_emitter(light_selector: LightSelector, config: RenderConfig) -> RayEmitter {
    let offset = 0.001:f32;

    @ |sample, x, y, _width, _height, payload| {
        let rnd = create_random_generator(create_random_seed(sample, config.iter, config.frame, x, y, config.seed));

        let (light, light_pdf) = light_selector.sample(rnd, vec3_expand(0));
        let sample_emission    = light.sample_emission;
        let light_sample       = @sample_emission(rnd);

        //let num_paths = width * height;
        let sample_f = 1:f32;//num_paths as f32;

        let ray      = make_option(make_ray(light_sample.pos, light_sample.dir, select(light.infinite, 0:f32, offset), flt_max, ray_flag_light));
        let radiance = color_mulf(light_sample.intensity, safe_div(math_builtins::fabs(light_sample.cos), light_pdf * sample_f));

        write_ltraypayload(payload, LTRayPayload {
            contrib = radiance,
            depth   = 1,
            eta     = 1
        });

        (ray, rnd)
    }
}

/////////////////////////////////////
/// TODO: This ignores the first vertex on the light surface
fn @make_lt_renderer(camera: Camera, framebuffer: AOVImage, max_path_len: i32, min_path_len: i32, clamp_value: f32) -> Technique {
    let offset : f32 = 0.001;
    let handle_color = make_std_color_handler(clamp_value);

    fn @on_shadow( ctx: ShadingContext
                 , rnd: RandomGenerator
                 , payload: RayPayload
                 , secondary_payload: RayPayload
                 , mat: Material
                 ) -> ShadowRay {
        // No shadow rays for specular materials
        if mat.bsdf.is_all_delta {
            return(ShadowRay::None)
        }
        
        let pt = unwrap_ltraypayload(payload);
        if pt.depth + 1 > max_path_len {
            return(ShadowRay::None)
        }

        if let Option[CameraSample]::Some(camera_sample) = camera.sample_pixel(rnd, ctx.surf.point) {
            let in_dir  = vec3_normalize(camera_sample.dir); 
            let out_dir = vec3_neg(ctx.ray.dir);
            let cos_o   = vec3_dot(out_dir, ctx.surf.local.col(2));
            let cos_i   = vec3_dot(in_dir, ctx.surf.local.col(2));

            if cos_o * cos_i > flt_eps {
                let d2      = vec3_len2(camera_sample.dir);
                let factor  = safe_div(cos_i, cos_o * d2);
                let contrib = handle_color(color_mulf(color_mul(camera_sample.weight, color_mul(pt.contrib, mat.bsdf.eval(out_dir, in_dir))), factor));

                write_ltsecondarypayload(secondary_payload, LTSecondaryPayload { pixel = make_vec2(camera_sample.coord.nx, camera_sample.coord.ny) });
                make_simple_shadow_ray(
                    make_ray(ctx.surf.point, camera_sample.dir, offset, 1 - offset, ray_flag_shadow),
                    contrib
                )
            } else {
                ShadowRay::None
            }
        } else {
            ShadowRay::None
        }
    }

    // No surface was between the surface and the camera -> There is a contribution from the light!
    fn @on_advanced_shadow_miss(ctx: ShadingContext, _shader: MaterialShader, secondary_payload: RayPayload, contrib: Color) -> Option[Color] {
        let lt = unwrap_ltsecondarypayload(secondary_payload);
        framebuffer.splat(make_pixelcoord_from_normalized(lt.pixel.x, lt.pixel.y, ctx.pixel.w, ctx.pixel.h), contrib);
        Option[Color]::None
    }

    // Same as pathtracer, except adjoint = true
    fn @on_bounce( ctx: ShadingContext
                 , rnd: RandomGenerator
                 , payload: RayPayload
                 , mat: Material
                 ) -> Option[Ray] {
        let pt = unwrap_ltraypayload(payload);

        if pt.depth + 1 > max_path_len {
            return(Option[Ray]::None)
        }

        // Bounce
        let out_dir = vec3_neg(ctx.ray.dir);
        if let Option[BsdfSample]::Some(mat_sample) = mat.bsdf.sample(rnd, out_dir, true) {
            // This should not really happen, but better be safe 
            if mat_sample.pdf <= flt_eps {
                return(Option[Ray]::None)
            }

            let contrib = color_mul(pt.contrib, mat_sample.color/* Pdf and cosine are already applied!*/);
            let rr_prob = if pt.depth + 1 > min_path_len { russian_roulette_pbrt(color_mulf(contrib, pt.eta * pt.eta), 0.95) } else { 1.0 };
            if rnd.next_f32() >= rr_prob {
                return(Option[Ray]::None)
            }

            let new_contrib = color_mulf(contrib, 1 / rr_prob);
            
            write_ltraypayload(payload, LTRayPayload {
                contrib = new_contrib,
                depth   = pt.depth + 1,
                eta     = pt.eta * mat_sample.eta
            });
            make_option(
                make_ray(ctx.surf.point, mat_sample.in_dir, offset, flt_max, ray_flag_bounce)
            )
        } else {
            Option[Ray]::None
        }
    }

    Technique {
        on_hit         = TechniqueNoHitFunction,
        on_miss        = TechniqueNoMissFunction,
        on_shadow      = on_shadow,
        on_bounce      = on_bounce,
        on_shadow_hit  = TechniqueNoShadowHitFunction,
        on_shadow_miss = on_advanced_shadow_miss,
    }
}
