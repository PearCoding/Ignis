// BVH layouts ---------------------------------------------------------------------

fn @make_cpu_node2(j: i32, nodes: &[Node2]) = Node {
    bbox = @ |i| {
        make_bbox(make_vec3(nodes(j).bounds(6 * i + 0), nodes(j).bounds(6 * i + 2), nodes(j).bounds(6 * i + 4)),
                  make_vec3(nodes(j).bounds(6 * i + 1), nodes(j).bounds(6 * i + 3), nodes(j).bounds(6 * i + 5)))
    },
    ordered_bbox = @ |i, octant| {
        let ox = (octant & 1);
        let oy = (octant & 2) >> 1;
        let oz = (octant & 4) >> 2;
        make_bbox(make_vec3(nodes(j).bounds(6 * i + 1 - ox), nodes(j).bounds(6 * i + 3 - oy), nodes(j).bounds(6 * i + 5 - oz)),
                  make_vec3(nodes(j).bounds(6 * i + 0 + ox), nodes(j).bounds(6 * i + 2 + oy), nodes(j).bounds(6 * i + 4 + oz)))
        // let ptr = &nodes(j).bounds as &[f32];
        // let align_ptr = @ |k: i32| rv_align(&ptr(k/4) as &i8, 16) as &[f32];
        // let get_f = @ |k: i32| ptr(k/4)
        // let ox = (octant & 1) << 2;
        // let oy = (octant & 2) << 1;
        // let oz = (octant & 4);
        // make_bbox(
        //     make_vec3(
        //         get_f(4  - ox)(i),
        //         get_f(12 - oy)(i),
        //         get_f(20 - oz)(i)
        //     ),
        //     make_vec3(
        //         get_f(0  + ox)(i),
        //         get_f(8  + oy)(i),
        //         get_f(16 + oz)(i)
        //     )
        // )
    },
    child = @ |i| nodes(j).child(i)
};

fn @make_cpu_node4(j: i32, nodes: &[Node4]) = Node {
    bbox = @ |i| {
        make_bbox(make_vec3(nodes(j).bounds(0)(i), nodes(j).bounds(2)(i), nodes(j).bounds(4)(i)),
                  make_vec3(nodes(j).bounds(1)(i), nodes(j).bounds(3)(i), nodes(j).bounds(5)(i)))
    },
    ordered_bbox = @ |i, octant| {
        let ox = (octant & 1);
        let oy = (octant & 2) >> 1;
        let oz = (octant & 4) >> 2;
        make_bbox(make_vec3(nodes(j).bounds(1 - ox)(i), nodes(j).bounds(3 - oy)(i), nodes(j).bounds(5 - oz)(i)),
                  make_vec3(nodes(j).bounds(0 + ox)(i), nodes(j).bounds(2 + oy)(i), nodes(j).bounds(4 + oz)(i)))
        // let ptr = &nodes(j).bounds as &[f32];
        // let align_ptr = @ |k: i32| rv_align(&ptr(k/4) as &i8, 16) as &[f32];
        // let get_f = @ |k: i32| ptr(k/4)
        // let ox = (octant & 1) << 2;
        // let oy = (octant & 2) << 1;
        // let oz = (octant & 4);
        // make_bbox(
        //     make_vec3(
        //         get_f(4  - ox)(i),
        //         get_f(12 - oy)(i),
        //         get_f(20 - oz)(i)
        //     ),
        //     make_vec3(
        //         get_f(0  + ox)(i),
        //         get_f(8  + oy)(i),
        //         get_f(16 + oz)(i)
        //     )
        // )
    },
    child = @ |i| nodes(j).child(i)
};

fn @make_cpu_node8(j: i32, nodes: &[Node8]) = Node {
    bbox = @ |i| {
        make_bbox(make_vec3(nodes(j).bounds(0)(i), nodes(j).bounds(2)(i), nodes(j).bounds(4)(i)),
                  make_vec3(nodes(j).bounds(1)(i), nodes(j).bounds(3)(i), nodes(j).bounds(5)(i)))
    },
    ordered_bbox = @ |i, octant| {
        let ox = (octant & 1);
        let oy = (octant & 2) >> 1;
        let oz = (octant & 4) >> 2;
        make_bbox(make_vec3(nodes(j).bounds(1 - ox)(i), nodes(j).bounds(3 - oy)(i), nodes(j).bounds(5 - oz)(i)),
                  make_vec3(nodes(j).bounds(0 + ox)(i), nodes(j).bounds(2 + oy)(i), nodes(j).bounds(4 + oz)(i)))
        // let ptr = &nodes(j).bounds as &[f32];
        // let align_ptr = @ |k: i32| rv_align(&ptr(k) as &i8, 32 /*FIXME: AVX code works with 16?*/) as &[f32];
        // let ox = (octant & 1) << 3;
        // let oy = (octant & 2) << 2;
        // let oz = (octant & 4) << 1;
        // make_bbox(
        //     make_vec3(
        //         align_ptr(8  - ox)(i),
        //         align_ptr(24 - oy)(i),
        //         align_ptr(40 - oz)(i)
        //     ),
        //     make_vec3(
        //         align_ptr(0  + ox)(i),
        //         align_ptr(16 + oy)(i),
        //         align_ptr(32 + oz)(i)
        //     )
        // )
    },
    child = @ |i| nodes(j).child(i)
};

// Special bbox intersectors

fn @make_cpu_entity_leaf(j: i32, objs: &[EntityLeaf1]) -> EntityLeaf {
    let d  = make_cpu_buffer(&objs(j) as &[f32], 0);
    let e0 = d.load_vec4(0);
    let e1 = d.load_vec4(4);
    let m  = d.load_mat3x4(8);
    let (f, mat_id, u1, u2) = d.load_int4(20);
    make_entity_leaf(
        make_bbox(make_vec3(e0.x, e0.y, e0.z),
                  make_vec3(e1.x, e1.y, e1.z)),
        bitcast[i32](e0.w),
        bitcast[i32](e1.w), mat_id, u1, u2,
        m,
        bitcast[u32](f)
    )
}

fn @make_cpu_bvh4_ent(nodes: &[Node4], objs: &[EntityLeaf1]) = SceneBvh {
    node = @ |j| make_cpu_node4(j, nodes),
    ent  = @ |j| make_cpu_entity_leaf(j, objs),
    prefetch = @ |id| {
        let ptr = select(id < 0, &objs(!id) as &[u8], &nodes(id - 1) as &[u8]);
        cpu_prefetch_bytes(ptr, 128)
    },
    arity = 4
};

fn @make_cpu_bvh8_ent(nodes: &[Node8], objs: &[EntityLeaf1]) = SceneBvh {
    node = @ |j| make_cpu_node8(j, nodes),
    ent  = @ |j| make_cpu_entity_leaf(j, objs),
    prefetch = @ |id| {
        let ptr = select(id < 0, &objs(!id) as &[u8], &nodes(id - 1) as &[u8]);
        cpu_prefetch_bytes(ptr, 256)
    },
    arity = 8
};

// Min/max functions ---------------------------------------------------------------

// Integer min/max instead of floating point min/max (~10-15% faster on x86, not measured on ARM)
// On x86, requires AVX2 when vectorizing with a vector length of 8, and
// requires SSE2 when vectorizing with a vector length of 4
fn @make_cpu_int_min_max() -> MinMax {
    let fminf = @ |x: f32, y: f32| {
        let (x_, y_) = (bitcast[i32](x), bitcast[i32](y));
        bitcast[f32](select(x_ < y_, x_, y_))
    };
    let fmaxf = @ |x: f32, y: f32| {
        let (x_, y_) = (bitcast[i32](x), bitcast[i32](y));
        bitcast[f32](select(x_ > y_, x_, y_))
    };
    make_min_max(fminf, fmaxf, true)
}
