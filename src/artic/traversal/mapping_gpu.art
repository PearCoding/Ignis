// BVH layout ----------------------------------------------------------------------

struct Node2 {
    bounds: [f32 * 12], // lo_x, hi_x, lo_y, hi_y, ...
    child:  [i32 * 2],
    pad:    [i32 * 2]
}

struct Tri1 {
    v0: [f32 * 3],
    pad: i32,
    e1: [f32 * 3],
    pad2: i32,
    e2: [f32 * 3],
    prim_id: i32,
    c0: [f32 * 2],
    c1: [f32 * 2],
    c2: [f32 * 2],
    pad3: [i32 * 2]
}

fn @make_gpu_node(j: i32, nodes: &[Node2], is_nvvm: bool) -> Node {
    let load4_f32 = @ |p: &addrspace(1)[simd[f32 * 4]], i: i32| if is_nvvm { nvvm_ldg4_f32(&p(i)) } else { p(i) };
    let load4_i32 = @ |p: &addrspace(1)[simd[i32 * 4]], i: i32| if is_nvvm { nvvm_ldg4_i32(&p(i)) } else { p(i) };
    
    let simd_ptr = &nodes(j) as &addrspace(1)[simd[f32 * 4]];
    let bb0      = load4_f32(simd_ptr, 0);
    let bb1      = load4_f32(simd_ptr, 1);
    let bb2      = load4_f32(simd_ptr, 2);
    let children = load4_i32(simd_ptr as &addrspace(1)[simd[i32 * 4]], 3);

    Node {
        bbox = @ |i| {
            if i == 0 {
                make_bbox(make_vec3(bb0(0), bb0(2), bb1(0)),
                          make_vec3(bb0(1), bb0(3), bb1(1)))
            } else {
                make_bbox(make_vec3(bb1(2), bb2(0), bb2(2)),
                          make_vec3(bb1(3), bb2(1), bb2(3)))
            }
        },
        ordered_bbox = @ |_, _| undef[BBox](), // Not implemented
        child = @ |i| children(i)
    }
}

fn @make_gpu_prim(j: i32, tris: &[Tri1], is_nvvm: bool, minmax : MinMax, disp_map : Image) -> Prim {
    let load4_f32 = @ |p: &addrspace(1)[simd[f32 * 4]], i: i32| if is_nvvm { nvvm_ldg4_f32(&p(i)) } else { p(i) };

    let simd_ptr = &tris(j) as &addrspace(1)[simd[f32 * 4]];
    let tri0     = load4_f32(simd_ptr, 0);
    let tri1     = load4_f32(simd_ptr, 1);
    let tri2     = load4_f32(simd_ptr, 2);
    let prim_id  = bitcast[i32](tri2(3));

    let c01 = load4_f32(simd_ptr, 3);
    let c2p = load4_f32(simd_ptr, 4);

    let v0  = make_vec3(tri0(0), tri0(1), tri0(2));
    let e1  = make_vec3(tri1(0), tri1(1), tri1(2));
    let e2  = make_vec3(tri2(0), tri2(1), tri2(2));
    let n = vec3_cross(e1, e2);
    
    let wc0 = make_vec2(c01(0), c01(1));
    let wc1 = make_vec2(c01(2), c01(3));
    let wc2 = make_vec2(c2p(0), c2p(1));
    
    let c0 = make_vec2(0,0);
    let c1 = make_vec2(1,0);
    let c2 = make_vec2(0,1);
    
    let uvtri = make_uv_tri(v0,e1,e2, n, c0, c1, c2, wc0, wc1, wc2);

    let min_max_displacement = @ |c1 : Vec2, c2 : Vec2| -> (f32, f32) {
        let min_px = (math_builtins::floor(minmax.fminf(c1.x, c2.x)) as i32) * disp_map.width;
        let min_py = (math_builtins::floor(minmax.fminf(c1.y, c2.y)) as i32) * disp_map.height;

        let max_px = (math_builtins::ceil(minmax.fmaxf(c1.x, c2.x)) as i32) * disp_map.width;
        let max_py = (math_builtins::ceil(minmax.fmaxf(c1.y, c2.y)) as i32) * disp_map.height;

        let mut min = flt_max;
        let mut max = flt_min;

        for y in range(min_py, max_py) {
            for x in range(min_px, max_px) {
                let d = disp_map.pixels(x,y).r;
                min = minmax.fminf(min, d);
                max = minmax.fmaxf(max, d);
            }
        }

        (min, max)
    };

    let displacement = @|c: Vec2| -> f32 {
        let px = c.x * (disp_map.width as f32);
        let py = c.y * (disp_map.height as f32);

        let hi_x = math_builtins::ceil(px) as i32;
        let lo_x = math_builtins::floor(px) as i32;

        let hi_y = math_builtins::ceil(py) as i32;
        let lo_y = math_builtins::floor(py) as i32;

        let frac_x = px - (lo_x as f32);
        let frac_y = py - (lo_y as f32);

        let v00 = disp_map.pixels(lo_x, lo_y).r;
        let v01 = disp_map.pixels(lo_x, hi_y).r;
        let v10 = disp_map.pixels(hi_x, lo_y).r;
        let v11 = disp_map.pixels(hi_x, hi_y).r;

        let v_y0 = frac_x * v00 + (1.0 - frac_x) * v10;
        let v_y1 = frac_x * v01 + (1.0 - frac_x) * v11;
        
        let val = (frac_y * v_y0 + (1.0 - frac_x) * v_y1);
        clampf(val, 0, 1);
        if (c.x > 0.5) {1}
        else {0}
    };

    let tesselate4 =  @|t:UVTri| {
        let v0 = t.v0;
        let e1 = t.e1;
        let e2 = t.e2;

        let c01 = vec2_lerp(t.c0, t.c1, 0.5);
        let c02 = vec2_lerp(t.c0, t.c2, 0.5);
        let c12 = vec2_lerp(t.c1, t.c2, 0.5);

        let wc01 = vec2_lerp(t.wc0, t.wc1, 0.5);
        let wc02 = vec2_lerp(t.wc0, t.wc2, 0.5);
        let wc12 = vec2_lerp(t.wc1, t.wc2, 0.5);

        let half_e1 = vec3_mulf(t.e1, 0.5);
        let half_e2 = vec3_mulf(t.e2, 0.5);

        let v01 = vec3_lerp(t.v0, t.v1, 0.5);
        let v02 = vec3_lerp(t.v0, t.v2, 0.5);
        let v12 = vec3_lerp(t.v1, t.v2, 0.5);
  
        // let tri0 = make_uv_tri(v0, half_e1, half_e2, t.n, c0, c01, c02, wc0, wc01, wc02);

        // let tri1 = make_uv_tri(v01, half_e1, half_e2, t.n, c01, c1, c12, wc01, wc1, wc12);
        
        // let tri2 = make_uv_tri(v02, half_e1, half_e2, t.n, c02, c12, c2, wc02, wc12, wc2);
        
        // let v = vec3_add(vec3_sub(v0, half_e1), half_e2);
        // let tri3 = make_uv_tri(v, vec3_mulf(half_e1, -1), vec3_mulf(half_e2, -1), t.n, c02, c12, c01, wc02, wc12, wc01);


        let n_new = vec3_cross(half_e1, half_e2);
        let tri0 = make_uv_tri(v0, half_e1, half_e2, n_new, c0, c01, c02, wc0, wc01, wc02);

        let tri1 = make_uv_tri(v01, half_e1, half_e2, n_new, c01, c1, c12, wc01, wc1, wc12);
        
        let tri2 = make_uv_tri(v02, half_e1, half_e2, n_new, c02, c12, c2, wc02, wc12, wc2);
        
        let ne1 = vec3_mulf(half_e1, 1);
        let ne2 = vec3_add(half_e1, half_e2);
        let tri3 = make_uv_tri(v01, ne1, ne2, vec3_cross(ne1, ne2), c12, c02, c01, wc12, wc02, wc01);

        (tri0, tri1, tri2, tri2)
    };

    let tesselate2 =  @|t:UVTri| {
        
        let v0 = t.v0;
        let v1 = t.v1;
        let v2 = t.v2;
        let v12 = vec3_lerp(v1, v2, 0.5);

        let c0 = t.c0;
        let c1 = t.c1;
        let c2 = t.c2;
        let c12 = vec2_lerp(t.c1, t.c2, 0.5);

        let wc0 = t.wc0;
        let wc1 = t.wc1;
        let wc2 = t.wc2;
        let wc12 = vec2_lerp(t.wc1, t.wc2, 0.5);

        let diag = vec3_sub(v12, v0);
        let e1 = vec3_sub(v1, v12);
        let tri0 = make_uv_tri(v12, diag, e1, vec3_cross(diag, e1), c12, c0, c1, wc12, wc0, wc1);
        let e2 = vec3_sub(v2, v12);
        let tri1 = make_uv_tri(v12, diag, e2, vec3_cross(diag, e2), c12, c0, c2, wc12, wc0, wc2);

        (tri0, tri1)
    };

    let tri_bbox = @|t:UVTri| {        
        let min_x = minmax.fminminf(t.v0.x, t.v1.x, t.v2.x);
        let min_y = minmax.fminminf(t.v0.y, t.v1.y, t.v2.y);
        let min_z = minmax.fminminf(t.v0.z, t.v1.z, t.v2.z);

        let max_x = minmax.fmaxmaxf(t.v0.x, t.v1.x, t.v2.x);
        let max_y = minmax.fmaxmaxf(t.v0.y, t.v1.y, t.v2.y);
        let max_z = minmax.fmaxmaxf(t.v0.z, t.v1.z, t.v2.z);
    
        make_bbox(
            make_vec3(min_x, min_y, min_z),
            make_vec3(max_x, max_y, max_z)
        )
    };

    let tri_uv = @ |p:Vec3, t:UVTri| -> Vec2 {
        let mut res = t.c0;
        let mut dist = vec3_dist(p, t.v0);

        let dist1 = vec3_dist(p, t.v1);
        if (dist1 < dist) {
            dist = dist1;
            res = t.c1;
        }

        let dist2 = vec3_dist(p, t.v2);
        if (dist2 < dist) {
            dist = dist2;
            res = t.c1;
        }

        res
    };

    let displace_tri = @ |t : UVTri| -> UVTri {
        let d0 = displacement(t.wc0);
        let d1 = displacement(t.wc1);
        let d2 = displacement(t.wc2);

        let nn = vec3_normalize(uvtri.n);

        let v0 = vec3_add(t.v0, vec3_mulf(nn, d0)); 
        let v1 = vec3_add(t.v1, vec3_mulf(nn, d1)); 
        let v2 = vec3_add(t.v2, vec3_mulf(nn, d2));

        let e1 = vec3_sub(v0, v1);
        let e2 = vec3_sub(v2, v0);

        let normal = vec3_cross(e1, e2);

        make_uv_tri(v0, e1, e2, normal, t.c0, t.c1, t.c2, t.wc0, t.wc1, t.wc2)
    };

    Prim {
        // intersect = @ |_, ray| {
        //     let mut closest = flt_max;
        //     let mut depth = 0;
        //     let mut current_tri = tri;

        //     let mut uv = make_vec2(0,0);

        //     while depth < 3 {
        //         let (t0, t1, t2, t3) = tesselate(current_tri);
        //         let tris = [t0,t1,t2,t3];

        //         for i in unroll(0,4) {
        //             let tri = tris(i);

        //             let bbox = tri_bbox(tris(i));
        //             if let Option[f32]::Some(entry) = intersect_ray_box_single(minmax, false, ray, bbox) {
        //                 if entry < closest {
        //                     closest = entry;
        //                     current_tri = tris(i);
        //                 }
        //             }
        //         }

        //         depth++;
        //     }

        //     let hit_point = vec3_add(ray.org, vec3_mulf(ray.dir, closest));
        //     uv = tri_uv(hit_point, current_tri);
    
        //     if closest != flt_max {
        //         make_option(make_hit(-1, prim_id & 0x7FFFFFFF, closest, uv))
        //     } else {
        //         Option[Hit]::None
        //     }
        // },

        intersect = @ |_, ray| {

            let mut tri_queue : [UVTri * 100];
            let mut queue_index = 0;

            let queue_tri = @|t:UVTri| {
                tri_queue(queue_index) = t;
                queue_index++;
            };

            let dequeue_tri = @|| -> Option[UVTri] {
                if (queue_index > 0) {
                    queue_index--;
                    Option[UVTri]::Some(tri_queue(queue_index))
                } else {
                    Option[UVTri]::None
                }
            };
            
            queue_tri(uvtri);

            let mut closest = flt_max;
            let mut uv = make_vec2(0,0);

            
            while queue_index > 0 {
                if let Option[UVTri]::Some(current_tri) = dequeue_tri() {
                    let (mut t0, mut t1) = tesselate2(current_tri);
                    let tris = [t0,t1];
                    
                    
                    //closest = flt_max;
                    
                    let mut found_hit = false;
                    for i in unroll(0,2) {
                        let tri = tris(i);
                        
                        let disp_tri = (displace_tri(tri));
                        let leaf = vec2_len(make_vec2(
                            minmax.fmaxmaxf(tri.wc0.x, tri.wc1.x, tri.wc2.x) - minmax.fminminf(tri.wc0.x, tri.wc1.x, tri.wc2.x),
                            minmax.fmaxmaxf(tri.wc0.y, tri.wc1.y, tri.wc2.y) - minmax.fminminf(tri.wc0.y, tri.wc1.y, tri.wc2.y)
                        )) < 0.05;

                        if (leaf) {
                            let isec_tri = uvtri2tri(disp_tri);
                            if let Option[(f32, f32, f32)]::Some((t, u, v)) = intersect_ray_tri(false, ray, isec_tri) {
                                
                                closest = t;
                                //uv = vec2_add(vec2_mulf(current_tri.c0, w), vec2_add(vec2_mulf(current_tri.c1, u), vec2_mulf(current_tri.c2, v)));
                                break;
                            }
                        } else {
                            if let Option[f32]::Some(t) = intersect_ray_box_single(minmax, false, ray, tri_bbox(disp_tri)) {
                                queue_tri(tri);
                            }
                        }
                    }
                }
            }
            
            if closest < flt_max {    
                let hit = vec3_add(ray.org, vec3_mulf(ray.dir, closest));
                let dir = uvtri.n;

                if let Option[(f32, f32, f32)]::Some((t,u,v)) = intersect_ray_tri(false, make_ray(hit, dir, -1, flt_max), uvtri2tri(uvtri)) {
                    uv = make_vec2(u, v);
                }

                make_option(make_hit(-1/* Will be set later*/, prim_id & 0x7FFFFFFF, closest, uv))
            } else {
                Option[Hit]::None
            }
        },
        is_valid = @ |_| true,
        is_last = prim_id < 0,
        size = 1
    }
}

fn @make_gpu_ent(j: i32, objs: &[EntityLeaf1], is_nvvm: bool) -> EntityLeaf {
    let d  = make_gpu_buffer(0/* Does not matter */, &objs(j) as &addrspace(1)[u8], 0, gpu_make_null_atomics(), is_nvvm);
    let e0 = d.load_vec4(0);
    let e1 = d.load_vec4(4);
    let m  = d.load_mat3x4(8);
    make_entity_leaf(
        make_bbox(make_vec3(e0.x, e0.y, e0.z),
                  make_vec3(e1.x, e1.y, e1.z)),
        bitcast[i32](e0.w),
        bitcast[i32](e1.w),
        m
    )
}

fn @make_gpu_bvh2_tri1(nodes: &[Node2], tris: &[Tri1], is_nvvm: bool, minmax : MinMax, disp_map: Image) -> PrimBvh {
    PrimBvh {
        node     = @ |j| @make_gpu_node(j, nodes, is_nvvm),
        prim     = @ |j| @make_gpu_prim(j, tris , is_nvvm, minmax, disp_map),
        prefetch = @ |_| (), // Not implemented
        arity    = 2
    }
}
fn @make_gpu_bvh2_ent(nodes: &[Node2], objs: &[EntityLeaf1], is_nvvm: bool) -> SceneBvh {
    SceneBvh {
        node     = @ |j| @make_gpu_node(j, nodes, is_nvvm),
        ent      = @ |j| @make_gpu_ent( j, objs , is_nvvm),
        prefetch = @ |_| (), // Not implemented
        arity    = 2
    }
}

// Min/Max functions  --------------------------------------------------------------

fn @make_nvvm_min_max() = MinMax {
    // Use video instructions to speed-up the ray-box test
    fminf = nvvm_fminf,
    fmaxf = nvvm_fmaxf,
    fminminf = @ |a, b, c| bitcast[f32](nvvm_minmin(bitcast[i32](a), bitcast[i32](b), bitcast[i32](c))),
    fmaxmaxf = @ |a, b, c| bitcast[f32](nvvm_maxmax(bitcast[i32](a), bitcast[i32](b), bitcast[i32](c))),
    fminmaxf = @ |a, b, c| bitcast[f32](nvvm_minmax(bitcast[i32](a), bitcast[i32](b), bitcast[i32](c))),
    fmaxminf = @ |a, b, c| bitcast[f32](nvvm_maxmin(bitcast[i32](a), bitcast[i32](b), bitcast[i32](c))),
    is_integer = true
};

fn @make_amdgpu_min_max() = make_min_max(ocml_fminf, ocml_fmaxf, false);

// Traversal kernel  ---------------------------------------------------------------

// Traverses a single ray at a time. 
fn @gpu_traverse_single_helper_prim( min_max: MinMax
                                    , mut ray: Ray
                                    , bvh: PrimBvh
                                    , any_hit: bool
                                    , root: i32
                                    ) -> Hit {
    let mut hit = empty_hit(ray.tmax);
    let stack   = alloc_stack();
    stack.push(root, undef[f32]());

    while !stack.is_empty() {
        let node_ref = stack.top();
        let node = bvh.node(node_ref.node - 1);

        let mut mask = 0;
        let small_stack = make_small_stack(bvh.arity);
        for k in unroll(0, bvh.arity) {
            let bbox = node.bbox(k);
            if likely(!bbox_is_empty(bbox)) {
                let (t0, t1) = intersect_ray_box(min_max, false, ray, bbox); 
                if t0 <= t1 {
                    mask |= 1 << k;
                    small_stack.write(k, (node.child(k), t0));
                }
            }
        }

        if bvh.arity == 2 {
            // Binary BVH
            if mask == 0 {
                stack.pop();
            } else {
                let (child0, t0) = small_stack.read(0);
                let (child1, t1) = small_stack.read(1);
                if mask == 3 {
                    let first  = select(t0 < t1, child0, child1);
                    let second = select(t0 < t1, child1, child0); 
                    stack.set_top(first, undef[f32]());
                    stack.push_after(second, undef[f32]());
                } else {
                    stack.set_top(select(mask == 1, child0, child1), undef[f32]());
                }
            }
        } else {
            // General case -- slower
            stack.pop();

            if mask != 0 {
                let mut tmin = ray.tmax;
                for k in unroll(0, bvh.arity) {
                    if mask & (1 << k) != 0 {
                        let (child, t) = small_stack.read(k);
                        if any_hit || t < tmin {
                            stack.push(child, undef[f32]());
                            tmin = t
                        } else {
                            stack.push_after(child, undef[f32]())
                        }
                    }
                }
            }
        }

        while is_leaf(stack.top()) {
            let leaf_ref = stack.pop();
            let mut prim_id = !leaf_ref.node;
            while true {
                let prim = bvh.prim(prim_id++);

                let mut tmin = ray.tmax;
                for k in unroll(0, prim.size) {
                    if !prim.is_valid(k) { break() }

                    if let Option[Hit]::Some(prim_hit) = prim.intersect(k, ray) {
                        //if (prim_hit.distance < tmin) {
                            hit = prim_hit;
                            tmin = prim_hit.distance;
                            //ray.tmax = prim_hit.distance;
                        //}

                        if any_hit { return(hit) }
                    }

                    // if let Option[f32]::Some(entry) = intersect_ray_box_single(min_max, true, ray, prim.bbox) {
                    //     hit = make_hit(-1, prim_id & 0x7FFFFFFF, entry, make_vec2(0,0));
                    //     ray.tmax = entry;

                    //     if any_hit {return(hit)}
                    // }
                }

                if prim.is_last { break() }
            }
        }
    }

    hit
}

// Traverses a single ray at a time. 
fn @gpu_traverse_single_helper( min_max: MinMax
                              , mut ray: Ray
                              , scene: SceneGeometry
                              , any_hit: bool
                              , root: i32
                              ) -> Hit {
    let mut hit = empty_hit(ray.tmax);

    let bvh       = scene.bvh;
    let prim_bvhs = scene.database.bvhs;
    let stack     = alloc_stack();
    stack.push(root, undef[f32]());

    while !stack.is_empty() {
        let node_ref = stack.top();
        let node = bvh.node(node_ref.node - 1);

        let mut mask = 0;
        let small_stack = make_small_stack(bvh.arity);
        for k in unroll(0, bvh.arity) {
            let bbox = node.bbox(k);
            if likely(!bbox_is_empty(bbox)) {
                let (t0, t1) = intersect_ray_box(min_max, false, ray, bbox);
                if t0 <= t1 {
                    mask |= 1 << k;
                    small_stack.write(k, (node.child(k), t0));
                }
            }
        }

        if bvh.arity == 2 {
            // Binary BVH
            if mask == 0 {
                stack.pop();
            } else {
                let (child0, t0) = small_stack.read(0);
                let (child1, t1) = small_stack.read(1);
                if mask == 3 {
                    let first  = select(t0 < t1, child0, child1);
                    let second = select(t0 < t1, child1, child0); 
                    stack.set_top(first, undef[f32]());
                    stack.push_after(second, undef[f32]());
                } else {
                    stack.set_top(select(mask == 1, child0, child1), undef[f32]());
                }
            }
        } else {
            // General case -- slower
            stack.pop();

            if mask != 0 {
                let mut tmin = ray.tmax;
                for k in unroll(0, bvh.arity) {
                    if mask & (1 << k) != 0 {
                        let (child, t) = small_stack.read(k);
                        if any_hit || t < tmin {
                            stack.push(child, undef[f32]());
                            tmin = t
                        } else {
                            stack.push_after(child, undef[f32]())
                        }
                    }
                }
            }
        }

        while is_leaf(stack.top()) {
            let leaf_ref   = stack.pop();
            let mut ref_id = !leaf_ref.node;
            while true {
                let leaf = bvh.ent(ref_id++);

                if let Option[(f32,f32)]::Some((tmin, _tmax)) = intersect_ray_box_single_section(min_max, false, ray, leaf.bbox) {
                    if tmin <= hit.distance {
                        let local_ray = transform_ray(ray, leaf.local);
                        let shape_bvh = @prim_bvhs(leaf.shape_id);

                        let shape = scene.database.shapes(leaf.shape_id);

                        let local_hit = gpu_traverse_single_helper_prim(min_max, local_ray, shape_bvh, any_hit, 1);

                        if local_hit.prim_id != -1 {
                            if local_hit.distance <= hit.distance {
                                hit      = make_hit(leaf.entity_id & 0x7FFFFFFF, local_hit.prim_id, local_hit.distance, local_hit.prim_coords);
                                ray.tmax = hit.distance;

                                // Early exit mode
                                if any_hit { return(hit) }
                            }
                        }
                    }
                }

                if leaf.entity_id < 0 { break() }
            }
        }
    }

    hit
}

// Wrapper  ------------------------------------------------------------------------
fn @gpu_traverse_single( acc: Accelerator
                       , min_max: MinMax
                       , scene: SceneGeometry
                       , rays: fn (i32, i32) -> Ray
                       , hits: fn (i32, i32, Hit) -> ()
                       , packet_size: i32
                       , num_packets: i32
                       , any_hit: bool
                       ) -> () {
    let block_size = 64;
    let ray_count  = num_packets * packet_size;
    let grid  = (round_up(num_packets, block_size), packet_size, 1);
    let block = (block_size, packet_size, 1);

    acc.exec(|work_item| {
        let (i, j) = (work_item.tidx() + work_item.bidx() * block_size, work_item.tidy());
        if (i + j) >= ray_count { return() }

        hits(i, j, gpu_traverse_single_helper(min_max, rays(i, j), scene, any_hit, 1 /*root*/));
    })(grid, block);
}
