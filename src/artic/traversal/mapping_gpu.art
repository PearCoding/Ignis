// BVH layout ----------------------------------------------------------------------

fn @make_gpu_node(j: i32, nodes: &[Node2], accessor: DeviceBufferAccessor) -> Node {
    let d = accessor(&nodes(j) as &[f32], 0);
    
    let bb0      = d.load_vec4( 0);
    let bb1      = d.load_vec4( 4);
    let bb2      = d.load_vec4( 8);
    let children = d.load_int4(12);

    Node {
        bbox = @ |i| {
            if i == 0 {
                make_bbox(make_vec3(bb0.x, bb0.z, bb1.x),
                          make_vec3(bb0.y, bb0.w, bb1.y))
            } else {
                make_bbox(make_vec3(bb1.z, bb2.x, bb2.z),
                          make_vec3(bb1.w, bb2.y, bb2.w))
            }
        },
        ordered_bbox = @ |_, _| undef[BBox](), // Not implemented
        child = @ |i| [children.0, children.1](i) // Only arity 2 supported
    }
}

fn @make_gpu_ent(j: i32, objs: &[EntityLeaf1], accessor: DeviceBufferAccessor) -> EntityLeaf {
    let d  = accessor(&objs(j) as &[f32], 0);
    let e0 = d.load_vec4(0);
    let e1 = d.load_vec4(4);
    let m  = d.load_mat3x4(8);
    let (f, mat_id, u1, u2) = d.load_int4(20);
    make_entity_leaf(
        make_bbox(make_vec3(e0.x, e0.y, e0.z),
                  make_vec3(e1.x, e1.y, e1.z)),
        bitcast[i32](e0.w),
        bitcast[i32](e1.w), mat_id, u1, u2,
        m,
        bitcast[u32](f)
    )
}

fn @make_gpu_bvh2_ent(nodes: &[Node2], objs: &[EntityLeaf1], accessor: DeviceBufferAccessor) -> SceneBvh {
    SceneBvh {
        node     = @ |j| @make_gpu_node(j, nodes, accessor),
        ent      = @ |j| @make_gpu_ent( j, objs , accessor),
        prefetch = @ |_| (), // Not implemented
        arity    = 2
    }
}

// Min/Max functions  --------------------------------------------------------------

fn @make_nvvm_min_max() = MinMax {
    // Use video instructions to speed-up the ray-box test
    fminf = nvvm_fminf,
    fmaxf = nvvm_fmaxf,
    fminminf = @ |a, b, c| bitcast[f32](nvvm_minmin(bitcast[i32](a), bitcast[i32](b), bitcast[i32](c))),
    fmaxmaxf = @ |a, b, c| bitcast[f32](nvvm_maxmax(bitcast[i32](a), bitcast[i32](b), bitcast[i32](c))),
    fminmaxf = @ |a, b, c| bitcast[f32](nvvm_minmax(bitcast[i32](a), bitcast[i32](b), bitcast[i32](c))),
    fmaxminf = @ |a, b, c| bitcast[f32](nvvm_maxmin(bitcast[i32](a), bitcast[i32](b), bitcast[i32](c))),
    is_integer = true
};

fn @make_amdgpu_min_max() = make_min_max(ocml_fminf, ocml_fmaxf, false);
