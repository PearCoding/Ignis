struct GlareSettings {
    max:                  f32,
    avg:                  f32,
    mul:                  f32,
    scale:                f32,
    vertical_illuminance: f32 // Set < 0 to compute it automatically
}

struct ReduceOutputGlare {
    num_pixels: i32,
    sum_omega:  f32,
    sum_lum:    f32,
    sum_x:      f32,
    sum_y:      f32,
    e_v:        f32,
}

// An evalglare.c implementation using the GPU.
// The biggest difference to the original code, beyond the missing features, is that it only supports a single glare source!
fn @compute_glare(device: Device, camera: Camera, input: AOVImage, source_luminance: DeviceBuffer, settings: &GlareSettings) {
    let width  = input.width;
    let height = input.height;

    //let cam_eye = registry::get_global_parameter_vec3("__camera_eye", vec3_expand(0));
    let cam_up  = vec3_normalize(registry::get_global_parameter_vec3("__camera_up", vec3_expand(0)));
    let cam_dir = vec3_normalize(registry::get_global_parameter_vec3("__camera_dir", vec3_expand(0)));

    let cam_hv = vec3_normalize(vec3_cross(cam_dir, cam_up));
    let cam_vv = vec3_normalize(vec3_cross(cam_dir, cam_hv));

    fn @calc_posindex(pixel: PixelCoord) -> f32 {
        let pseudo_rng = create_random_generator(42);
        let ray = camera.generate_ray(pseudo_rng, pixel);

        let vangle = math_builtins::acos(vec3_dot(cam_vv, ray.dir)) - flt_pi / 2.0;
        let hangle = flt_pi / 2.0 - math_builtins::acos(vec3_dot(cam_hv, ray.dir));
        let t      = vec3_dot(cam_dir, ray.dir);
        let sigma  = deg(math_builtins::fabs(math_builtins::acos(t)));

        let hv  = vec3_normalize(vec3_sub(vec3_mulf(ray.dir, 1.0 / t), ray.dir));
        let tau = deg(math_builtins::acos(vec3_dot(cam_vv, hv)));

        let phi   = math_builtins::fmax[f32](0.00001:f32, vangle);
        let theta = math_builtins::fmax[f32](0.00001:f32, hangle);

        // position index calculation with KIM model (postype==1)
        //posindex = math_builtins::exp ((sigma-(-0.000009*tau*tau*tau+0.0014*tau*tau+0.0866*tau+21.633))/(-0.000009*tau*tau*tau+0.0013*tau*tau+0.0853*tau+8.772));
        
	    let posindex = if (phi < 0.0) {
            // use Iwata model below line of sight
            let d = 1.0 / math_builtins::tan(phi);
            let s = math_builtins::tan(theta) / math_builtins::tan(phi);
            let r = math_builtins::fmin[f32](math_builtins::sqrt(1.0 / d * 1.0 / d + s * s / d / d), 3.0:f32);

            let fact = select(r > 0.6, 1.2:f32, 0.8:f32);

            1.0 + fact * r
	    } else {
            // position index calculation with Guth model
            math_builtins::exp((35.2 - 0.31889 * tau - 1.22 * math_builtins::exp(-2 * tau / 9)) / 1000 * sigma + (21 + 0.26667 * tau - 0.002963 * tau * tau) / 100000 * sigma * sigma)
        };

        math_builtins::fmin[f32](posindex, 16:f32)
    }

    // Loosely adapted from pict_get_omega, pict_get_sangle and splane_normal
    fn @calc_omega(pixel: PixelCoord) -> (f32, Vec3) {
        fn @splane(p_a: Vec3, p_b: Vec3) -> Vec3 {
            let e1 = p_a;
            let e2 = vec3_sub(p_b, p_a);
            let n  = vec3_cross(e1, e2);
            select(vec3_len2(n) > 0, vec3_normalize(n), vec3_expand(0))
        }

        let pseudo_rng = create_random_generator(42);
        let r1 = camera.generate_ray(pseudo_rng, pixel).dir;
        let r2 = camera.generate_ray(pseudo_rng, shift_pixelcoord(pixel, 0, 1)).dir;
        let r3 = camera.generate_ray(pseudo_rng, shift_pixelcoord(pixel, 1, 1)).dir;
        let r4 = camera.generate_ray(pseudo_rng, shift_pixelcoord(pixel, 1, 0)).dir;

        let n1 = splane(r1, r2);
        let n2 = splane(r2, r3);
        let n3 = splane(r3, r4);
        let n4 = splane(r4, r1);

        let a1 = flt_pi - math_builtins::fabs(math_builtins::acos(vec3_dot(n1, n2)));
        let a2 = flt_pi - math_builtins::fabs(math_builtins::acos(vec3_dot(n2, n3)));
        let a3 = flt_pi - math_builtins::fabs(math_builtins::acos(vec3_dot(n3, n4)));
        let a4 = flt_pi - math_builtins::fabs(math_builtins::acos(vec3_dot(n4, n1)));

        let ang = a1 + a2 + a3 + a4;
        (ang - 2 * flt_pi, r1)
    }

    let scale     = settings.scale;
    let luminance = @|col:Color| -> f32 { color_builtins::white_efficiency * color_luminance(col) * scale }; // Only luminance. In contrary to other parts this is explicit in Lux (assuming sRGB).

    let lum_max    = color_builtins::white_efficiency * settings.max;
    let lum_source = color_builtins::white_efficiency * settings.avg * settings.mul;

    let reduce_handler = device.parallel_reduce_handler;
    let reduce_output  = reduce[ReduceOutputGlare](reduce_handler, width * height,
        @|i:i32| {
            let pixel        = make_pixelcoord_from_linear(i, width, height, 0, 0);
            let (omega, dir) = calc_omega(pixel);
            let act_lum      = luminance(input.get(pixel));
            let cos_f        = math_builtins::fabs(vec3_dot(cam_dir, dir));
            let e_v          = act_lum * omega * cos_f;
            if act_lum > lum_source {
                ReduceOutputGlare {
                    num_pixels = 1,
                    sum_omega  = omega,
                    sum_lum    = act_lum * omega,
                    sum_x      = pixel.x as f32 * omega,
                    sum_y      = pixel.y as f32 * omega,
                    e_v        = e_v
                }
            } else {
                ReduceOutputGlare {
                    num_pixels = 0,
                    sum_omega  = 0,
                    sum_lum    = 0,
                    sum_x      = 0,
                    sum_y      = 0,
                    e_v        = e_v // Independent of the glare source
                }
            }
        },
        @|a, b| { ReduceOutputGlare{ 
            num_pixels = a.num_pixels + b.num_pixels,
            sum_omega  = a.sum_omega  + b.sum_omega,
            sum_lum    = a.sum_lum    + b.sum_lum,
            sum_x      = a.sum_x      + b.sum_x,
            sum_y      = a.sum_y      + b.sum_y,
            e_v        = a.e_v        + b.e_v } }
    );

    let glare_pixels = reduce_output.num_pixels;
    let glare_omega  = reduce_output.sum_omega;
    let glare_lum    = reduce_output.sum_lum / glare_omega;
    let glare_x      = reduce_output.sum_x / glare_omega;
    let glare_y      = reduce_output.sum_y / glare_omega;
    let E_v          = if settings.vertical_illuminance < 0 { reduce_output.e_v } else { settings.vertical_illuminance };

    // primary glare source scan
    for idx in device.parallel_range(0, width * height) {
        let pixel         = make_pixelcoord_from_linear(idx, width, height, 0, 0);
        let current_color = input.get(pixel);
        let act_lum       = luminance(current_color);

        let rel_luminance = if (act_lum > lum_source) {
            // compute relative luminance
            let max_diff = math_builtins::fmax(flt_eps, lum_max - lum_source);
            let lum_diff = act_lum - lum_source;
            lum_diff / max_diff
        } else {
            0:f32
        };
        source_luminance.store_f32(pixel.linear, rel_luminance);
    }

    let glare_posi = calc_posindex(make_pixelcoord_from_xy(glare_x as i32, glare_y as i32, width, height, math::fract(glare_x), math::fract(glare_y)));

    fn @compute_dgp() -> f32 {
        let c1 = 5.87e-5 : f32;
        let c2 = 0.092   : f32;
        let c3 = 0.159   : f32;
        let a1 = 2.0     : f32;
        let a2 = 1.0     : f32;
        let a3 = 1.87    : f32;
        let a4 = 2.0     : f32;
        let a5 = 1.0     : f32;

        let dgp_acc    = math_builtins::pow(glare_lum, a1) / math_builtins::pow(glare_posi, a4) * math_builtins::pow(glare_omega, a2) / math_builtins::pow(E_v, a3);
        let source_dgp = math_builtins::log10(1 + dgp_acc);

        if glare_pixels > 0 {
            c1 * math_builtins::pow(E_v, a5) + c2 * source_dgp + c3
        } else {
            // No glare sources
            c1 * math_builtins::pow(E_v, a5) + c3
        }
    }

    fn @compute_dgi() -> f32 {
        let lum_backg = settings.avg; // TODO: Really?
        let omega_s   = glare_omega / (glare_posi * glare_posi);
        let sum_glare = 0.478 * math_builtins::pow(glare_lum, 1.6:f32) * math_builtins::pow(omega_s, 0.8:f32) / (lum_backg + 0.07 * math_builtins::pow(glare_omega, 0.5:f32) * glare_lum);
        10 * math_builtins::log10(sum_glare)
    }

    fn @compute_dgi_mod() -> f32 {
        let lum_a     = settings.avg; // TODO: Really?
        let omega_s   = glare_omega / (glare_posi * glare_posi);
        let sum_glare = 0.478 * math_builtins::pow(glare_lum, 1.6:f32) * math_builtins::pow(omega_s, 0.8:f32) / (math_builtins::pow(lum_a, 0.85:f32) + 0.07 * math_builtins::pow(glare_omega, 0.5:f32) * glare_lum);
        10 * math_builtins::log10(sum_glare)
    }

    // TODO: Add low-light correction
    // TODO: Add age correction

    let dgp     = compute_dgp();
    let dgi     = compute_dgi();
    let dgi_mod = compute_dgi_mod();

    registry::set_global_parameter_f32("glare_dgp", dgp);
    registry::set_global_parameter_f32("glare_dgi", dgi);
    registry::set_global_parameter_f32("glare_dgi_mod", dgi_mod);
    registry::set_global_parameter_f32("glare_vertical_illuminance", E_v);
    registry::set_global_parameter_f32("glare_source_luminance", glare_lum);
    registry::set_global_parameter_f32("glare_omega", glare_omega);
    registry::set_global_parameter_i32("num_glare_pixels", glare_pixels);

    device.sync();
}