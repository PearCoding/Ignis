fn @handle_perspective_shader(device: Device, spi: i32, settings: &Settings) -> () {
    let input_width   = settings.width;
    let input_height  = settings.height;
    let output_width  = registry::get_local_parameter_i32("_output_width",    128);
    let output_height = registry::get_local_parameter_i32("_output_height",   128);
    let pers_fov      = rad(registry::get_local_parameter_f32("_perspective_fov", 60));

    // let framebuffer = attach_mitchell_filter(device.load_aov_image("", spi), 2);
    let framebuffer = device.load_aov_image("", spi);
    let output      = device.request_buffer("_perspective_output", output_width * output_height, 0);

    // let camera_eye = registry::get_global_parameter_vec3("__camera_eye", vec3_expand(0));
    // let camera_dir = registry::get_global_parameter_vec3("__camera_dir", vec3_expand(0));
    // let camera_up  = registry::get_global_parameter_vec3("__camera_up" , vec3_expand(0));

    let camera_eye = make_vec3(0,0,0);
    let camera_dir = make_vec3(0,0,1);
    let camera_up  = make_vec3(0,1,0);

    let scale = if settings.iter > 0 { 1 / settings.iter as f32 } else { 0 }; // TODO: This is a job for tonemapping

    let pers_scale = compute_scale_from_hfov(pers_fov, output_width as f32 / output_height as f32);

    let cam_perspective = make_perspective_camera(camera_eye, camera_dir, camera_up, pers_scale, output_width, output_height, 0, 100);
    let cam_fisheye     = make_fishlens_camera(camera_eye, camera_dir, camera_up, input_width, input_height, FisheyeAspectMode::Circular /* Fixed in code */, 0, 100);

    for x, y in device.parallel_range_2d(0, output_width, 0, output_height) {
        let dstCoord = make_pixelcoord_from_xy(x, y, output_width, output_height, 0, 0);

        let rnd = create_random_generator(0xdeadbeef);
        let ray = cam_perspective.generate_ray(rnd, dstCoord);

        // let color = make_color((dstCoord.nx+1)/2, 0, (dstCoord.ny+1)/2, 1);
        let color = if let Option[PixelCoord]::Some(srcCoord) = cam_fisheye.pos_to_pixel(vec3_add(ray.org, ray.dir)) {
            // make_color((srcCoord.nx+1)/2, 0, (srcCoord.ny+1)/2, 1)
            color_mulf(framebuffer.get(srcCoord), scale)
            // color_mulf(framebuffer.get(make_pixelcoord_from_normalized(dstCoord.nx, dstCoord.ny, input_width, input_height)), scale)
        } else {
            color_builtins::pink
        };

        output.store_i32(dstCoord.linear, bitcast[i32](make_byte_color(color)));
    }

    device.sync();
}