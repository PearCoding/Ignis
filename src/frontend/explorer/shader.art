fn @handle_perspective_shader(device: Device, spi: i32, settings: &Settings) -> () {
    let input_width   = settings.width;
    let input_height  = settings.height;
    let canvas_width  = registry::get_global_parameter_i32("_canvas_width",  128);
    let canvas_height = registry::get_global_parameter_i32("_canvas_height", 128);
    let pers_fov      = rad(registry::get_global_parameter_f32("_canvas_fov", 60));

    let framebuffer = attach_lanczos_filter(device.load_aov_image("", spi), 3, 3);
    // let framebuffer = device.load_aov_image("", spi);
    let output      = device.request_buffer("_perspective_output", canvas_width * canvas_height * 3, 0);

    // let camera_eye = registry::get_global_parameter_vec3("__camera_eye", vec3_expand(0));
    // let camera_dir = registry::get_global_parameter_vec3("__camera_dir", vec3_expand(0));
    // let camera_up  = registry::get_global_parameter_vec3("__camera_up" , vec3_expand(0));

    let camera_eye = make_vec3(0,0,0);
    let camera_dir = make_vec3(0,0,1);
    let camera_up  = make_vec3(0,1,0);

    let pers_scale = compute_scale_from_hfov(pers_fov, canvas_width as f32 / canvas_height as f32);

    let cam_perspective = make_perspective_camera(camera_eye, camera_dir, camera_up, pers_scale, canvas_width, canvas_height, 0, 100);
    let cam_fisheye     = make_fishlens_camera(camera_eye, camera_dir, camera_up, input_width, input_height, FisheyeAspectMode::Circular /* Fixed in code */, 0, 100);

    for x, y in device.parallel_range_2d(0, canvas_width, 0, canvas_height) {
        let dstCoord = make_pixelcoord_from_xy(x, y, canvas_width, canvas_height, 0, 0);

        let rnd = create_random_generator(0xdeadbeef);
        let ray = cam_perspective.generate_ray(rnd, dstCoord);

        // let color = make_color((dstCoord.nx+1)/2, 0, (dstCoord.ny+1)/2, 1);
        let color = if let Option[PixelCoord]::Some(srcCoord) = cam_fisheye.pos_to_pixel(vec3_add(ray.org, ray.dir)) {
            // make_color((srcCoord.nx+1)/2, 0, (srcCoord.ny+1)/2, 1)
            framebuffer.get(srcCoord)
            // framebuffer.get(make_pixelcoord_from_normalized(dstCoord.nx, dstCoord.ny, input_width, input_height))
        } else {
            color_builtins::pink
        };

        output.store_vec3(dstCoord.linear * 3, color_to_vec3(color));
    }

    device.sync();
}

fn @handle_tonemap_shader(device: Device, _spi: i32, settings: &Settings) -> () {
    let width  = registry::get_global_parameter_i32("_canvas_width",  128);
    let height = registry::get_global_parameter_i32("_canvas_height", 128);
    let input  = make_aov_image_from_buffer(device.request_buffer("_perspective_output", width * height * 3, 0), width, height);
    let output = device.request_buffer("_tonemap_output", width * height, 0);

    let tonemapSettings = TonemapSettings{
        scale           = 1 / (settings.iter + 1) as f32,
        use_gamma       = true,
        method          = registry::get_local_parameter_i32("_tonemap_method", 0),
        exposure_factor = registry::get_local_parameter_f32("_tonemap_exposure_factor", 1),
        exposure_offset = registry::get_local_parameter_f32("_tonemap_exposure_offset", 0)
    };

    ig_tonemap_pipeline2(device, input, output, &tonemapSettings);
}

fn @handle_glare_shader(device: Device, spi: i32, settings: &Settings) -> () {
    let width  = settings.width;
    let height = settings.height;
    let input  = attach_lanczos_filter(device.load_aov_image("", spi), 3, 3);
    // let input  = device.load_aov_image("", spi);
    let source_luminance = device.request_buffer("_glare_source_luminance", width * height, 0);

    let camera_eye  = registry::get_global_parameter_vec3("__camera_eye", vec3_expand(0));
    let camera_dir  = registry::get_global_parameter_vec3("__camera_dir", vec3_expand(0));
    let camera_up   = registry::get_global_parameter_vec3("__camera_up" , vec3_expand(0));
    let cam_fisheye = make_fishlens_camera(camera_eye, camera_dir, camera_up, width, height, FisheyeAspectMode::Circular /* Fixed in code */, 0, 100);

    let glareSettings = GlareSettings{
        scale = 1 / (settings.iter + 1) as f32,
        max   = registry::get_global_parameter_f32("_luminance_max", 1),
        avg   = registry::get_global_parameter_f32("_luminance_avg", 1),
        mul   = registry::get_global_parameter_f32("_glare_multiplier", 1),
        vertical_illuminance = registry::get_global_parameter_f32("_glare_vertical_illuminance", -1)
    };

    compute_glare(device, cam_fisheye, input, source_luminance, &glareSettings);
}

fn @handle_overlay_shader(device: Device, spi: i32, settings: &Settings) {
    let input_width   = settings.width;
    let input_height  = settings.height;
    let canvas_width  = registry::get_global_parameter_i32("_canvas_width",  128);
    let canvas_height = registry::get_global_parameter_i32("_canvas_height", 128);
    let pers_fov      = rad(registry::get_global_parameter_f32("_canvas_fov", 60));
    
    let framebuffer = attach_lanczos_filter(device.load_aov_image("", spi), 3, 3);
    let source_lum  = device.request_buffer("_glare_source_luminance", input_width * input_width, 0);
    let tonemapped  = device.request_buffer("_tonemap_output", canvas_width * canvas_height, 0);
    let output      = device.request_buffer("_overlay_output", canvas_width * canvas_height, 0);

    let camera_eye = make_vec3(0,0,0);
    let camera_dir = make_vec3(0,0,1);
    let camera_up  = make_vec3(0,1,0);

    let pers_scale = compute_scale_from_hfov(pers_fov, canvas_width as f32 / canvas_height as f32);

    let cam_perspective = make_perspective_camera(camera_eye, camera_dir, camera_up, pers_scale, canvas_width, canvas_height, 0, 100);
    let cam_fisheye     = make_fishlens_camera(camera_eye, camera_dir, camera_up, input_width, input_height, FisheyeAspectMode::Circular /* Fixed in code */, 0, 100);

    let scale   = 1 / (settings.iter + 1) as f32;
    let lum_min = registry::get_global_parameter_f32("_luminance_softmin", 0);
    let lum_max = registry::get_global_parameter_f32("_luminance_softmax", 1);

    fn @run_glare_overlay() {
        for x, y in device.parallel_range_2d(0, canvas_width, 0, canvas_height) {
            let dstCoord = make_pixelcoord_from_xy(x, y, canvas_width, canvas_height, 0, 0);

            let rnd = create_random_generator(0xdeadbeef);
            let ray = cam_perspective.generate_ray(rnd, dstCoord);

            let rel_lum = if let Option[PixelCoord]::Some(srcCoord) = cam_fisheye.pos_to_pixel(vec3_add(ray.org, ray.dir)) {
                source_lum.load_f32(srcCoord.linear)
            } else {
                0
            };

            let tonemap_color  = make_color_from_byte(bitcast[u32](tonemapped.load_i32(dstCoord.linear)));
            let colormap_color = colormap::inferno(rel_lum);

            let t     = math_builtins::fmin(rel_lum, 0.1 : f32) / 0.1;
            let color = color_lerp(tonemap_color, colormap_color, t);
            output.store_i32(dstCoord.linear, bitcast[i32](make_byte_color(color)));
        }
    }

    fn @run_luminance_overlay(squared: bool) {
        for x, y in device.parallel_range_2d(0, canvas_width, 0, canvas_height) {
            let dstCoord = make_pixelcoord_from_xy(x, y, canvas_width, canvas_height, 0, 0);

            let rnd = create_random_generator(0xdeadbeef);
            let ray = cam_perspective.generate_ray(rnd, dstCoord);

            let color = if let Option[PixelCoord]::Some(srcCoord) = cam_fisheye.pos_to_pixel(vec3_add(ray.org, ray.dir)) {
                framebuffer.get(srcCoord)
            } else {
                color_builtins::black
            };

            let lum = color_luminance(color) * scale;

            let rel = clampf((lum - lum_min) / (lum_max - lum_min), 0, 1);
            let out_color = colormap::inferno(if squared { rel * rel } else { rel });

            output.store_i32(dstCoord.linear, bitcast[i32](make_byte_color(out_color)));
        }
    }
 
    let method = registry::get_global_parameter_i32("_overlay_method", 0); // RenderWidget::OverlayMethod
    match method {
        1 => run_luminance_overlay(false),
        2 => run_luminance_overlay(true),
        _ => run_glare_overlay(),
    }

    device.sync();
}

fn @handle_imageinfo_shader(device: Device, _spi: i32, settings: &Settings) {
    let width  = registry::get_global_parameter_i32("_canvas_width",  128);
    let height = registry::get_global_parameter_i32("_canvas_height", 128);
    let input  = make_aov_image_from_buffer(device.request_buffer("_perspective_output", width * height * 3, 0), width, height);

    let imageinfoSettings = ImageInfoSettings{
        scale           = 1 / (settings.iter + 1) as f32,
        bins            = 0,
        histogram_r     = undef[&mut [i32]](),
        histogram_g     = undef[&mut [i32]](),
        histogram_b     = undef[&mut [i32]](),
        histogram_l     = undef[&mut [i32]](),
        acquire_error_stats = false,
        acquire_histogram   = false
    };

    let output = ig_imageinfo_pipeline2(device, input, &imageinfoSettings);

    registry::set_global_parameter_f32("_luminance_max",     output.max);
    registry::set_global_parameter_f32("_luminance_min",     output.min);
    registry::set_global_parameter_f32("_luminance_avg",     output.avg);
    registry::set_global_parameter_f32("_luminance_softmax", output.soft_max);
    registry::set_global_parameter_f32("_luminance_softmin", output.soft_min);
    registry::set_global_parameter_f32("_luminance_med",     output.median);
}